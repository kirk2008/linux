==============================================================
                    1  vim安装以及定位vimrc
==============================================================
1.1. 安装 neovim
    1.1.1. linux 安装 neovim
        apt install neovim

    1.1.2. 针对windows平台，可以使用
        // 使用Scoop
        scoop install neovim
        // 或者chocolatey
        choco instal neovim

    1.1.3. 在终端中使用nvim 来打开，可用别名来将vim映射为nvim
        alias vim='nvim'

    1.1.4. 对于mac平台来说，可以使用homebrew来安装
        brew install neovim

1.2. 配置 neovim
    1.2.1. macOS 和 Linux上neovim配置文件位于
        ~/.config/nvim/init.lua，
        Windows上的配置文件位于
        C:/User/用户/AppData/Local/nvim/init.lua。
        这里我们也可以将文件名改为init.vim这样我们可以使用vimscript，.lua可以使用lua语言进行配置。
    1.2.2. 这里给出vimscript和lua的最基础的配置
        " vimrc 配置
        set number "设置行号
        syntax on " 打开语法高亮
        set relativenumber "设置相对行号 
        set nocompatiable "设置与vi不兼容
        set wrap "设置自动换行
        set ruler "设置右侧底部显示输入命令
        set incsearch "设置搜索高亮

        -- lua配置
        vim.o.syntax = "enable"
        vim.o.relativenumber = true
        vim.o.wrap = true
        vim.o.ruler = true
        vim.o.incsearch = true


==============================================================
                    2 vim 模式
==============================================================

2.1. vim的几种模式
    2.1.1 普通模式 (normal mode)
        在使用vim的时候大部分时间停留在普通模式下，并且很多操作都是在普通模式下完成的，例如上述的几个例子全都是在普通模式下完成的。移动光标、切换模式都是在普通模式下进行的
    2.1.2 插入模式 (insert mode)
        插入模式主要用来编辑文本，在该模式下输入的字符都会作为文本的一部分进行保存，在该模式下可以进行文本的编辑操作
    2.1.3 可视模式(visual mode)
        该模式主要用来选择一部分文本，实现的功能跟用鼠标选中一段文本一样，后续可以输入命令针对被选中的文本进行处理
    2.1.4 命令行模式(command mode)
        在普通模式和可视模式下输入 : 进入命令行模式，严格意义上来说，它并不是一个真正的模式。许多复杂的操作其实都可通过一个简单的命令来完成。在命令行中，我们可以执行 vim 自带的命令，也可以执行自定义的命令(例如很多插件都有一些自定义命令)。例如使用 :w 来将缓冲区中的内容写入一个文件中，或者使用:q 来退出vim。
2.2. vim 移动光标的几种方式 
    motion = [数字] + 移动光标

    h: 向前移动一个字符
    l: 向后移动一个字符
    j: 向下移动一行//J将多行合并成1行
    k: 向上移动一行
    b: 向前移动一个单词
    w: 向后移动一个单词
    e: 移动光标到单词尾部
    ge:向后移动光标到单词尾部
    ^: 移动光标到行首第一个非空字符处
    $: 移动光标到行末最后一个非空字符处
    gg: 移动光标至文件首行的首个非空格字节
    G: 移动光标至整个文本最后一行的首个非空格字节()
    %: 移动光标到匹配括号的另一端
    0: 移动光标至行首
   
    ctr+o/O， 跳到上一个位置
    ctr+i/I，跳到下一个位置
    ''     ，当前位置和上一个位置来回跳

2.3. vim 基础操作之删除和替换 

    3.1 单次操作
    operate = operator + motion 
            = operator + [数字] + 移动光标
    d2w 表示一次删除两个单词

    3.2 多次操作
    我们也可以在 operator 前添加数字，表示执行操作重复次数，这里我们的公式就可以进行改写
    operate = [数字] + operator + motion
            = [数字] + ooperator + [数字] + 移动光标
    例如2dw 表示删除一个单词并将该操作执行两遍，2d2w也是合法操作

    3.3 以行为单位的操作
        重复按下两次同样的操作命令表示针对行进行操作，前面加上数字表示重复多少次。
        operate = [数字] + 2 * operator
        例如：
            5dd 删除接下来5行
            4>> 将接下来的4行代码进行缩进
            2cc 更改接下来的两行，并进入插入模式

    d：删除，该命令与motion配置使用，表示删除光标移动过的所有内容
    c：修改，删除当前并切换到 insert mode
    >: 右缩进
    <: 左缩进
    =: 自动缩进
    y: 复制
    p: 粘贴
    gu+[Enter]: 变为小写
    gU+[Enter]: 变为大写
    g~+[Enter]: 反转大小写
    ~: 反转大小写
    示例：使用>G 将当前行至文件尾部的代码进行缩进

    1. 单个字符的处理
        ~：切换光标所在位置的字符的大小写形式，大写转换为小写，小写转换为大写
        3~：将光标位置开始的3个字母改变其大小写
    2. 文本整体的处理
        gu：切换为小写，gU：切换为大写，剩下的就是对这两个命令的限定（限定行字母和单词）等等。

        2.1 整篇文章
            无须进入命令行模式，键入：

            ggguG：整篇文章转换为小写，gg：文件头，G：文件尾，gu：切换为小写
            gggUG：整篇文章切换为大写，gg：文件头，G：文件尾，gU：切换为大写
        2.2 只转化某个单词
            guw、gue
            gUw、gUe
            gu5w：转换 5 个单词
            gU5w
            gul:当前光标所在字母
            guh:当前光标前面的字母
        2.3 转换行
            gU0 ：从光标所在位置到行首，都变为大写
            gU$ ：从光标所在位置到行尾，都变为大写
            gUG ：从光标所在位置到文章最后一个字符，都变为大写
            gU1G ：从光标所在位置到文章第一个字符，都变为大写

一般模式下的复制黏贴
 5.1 复制行
     yy：复制游标所在的那一行(常用)
     nyy：n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行
     y1G：复制游标所在行到第一行的所有数据
     yG：复制游标所在行到最后一行的所有数据
     Gy:同yG
 5.2 复制多个字符
         nx：连续向后复制 n 个字符。用 p/P 可以粘贴。
         y$：复制游标所在处，到该行的最后一个字符，用 p/P 可以粘贴。
         y0：复制游标所在处，到该行的最前面一个字符，用 p/P 可以粘贴
         yw：复制光标后面的单词，包括空格
         yiw：复制光标所在的单词，但不包括单词旁边的空格
         yaw：复制光标所在的单词，包括单词旁边的空格
         yh：复制光标所在的前一个字符
         yl：复制光标所在的后一个字符
         nyh：复制光标所在的前n个字符
         nyl：复制光标所在的后n个字符
         移动命令前面加y 都可以复制该区域 eg：
         yt'字符': 复制光标所在处, 到该行向后的字符'字符'的位置,
         
         
         f+字符：移动至行内当前光标后面的第一个这个字符
         t+字符：移动至行内当前光标后的的第一个这个字符的前一个位置
         F+字符：f+字符的反向
         T+字符；t+字符的反向
         ······
         ······

==============================================================
                    3 vim 普通模式
==============================================================
3.1. 行内查找字符串
    f{char}:使跳转到行内第一个出现该字符的位置
        根据公式motion = [数字] + 移动光标我们可以使用 
            2fr 跳转到第二个r 位置
    t{char}: t 跳转光标到指定字符的前一个位置
    F 和 T 实现向前查找，它门跳转的规则与 f 和 t 类似
    ；和，正向或反向重复跳转
    ;:重复上次查找
3.2. 大范围移动
    {：将光标移到上一个空白行（段落的开头）。
    2{：将光标移到上两个空白行（两个段落的开头）。
    {（在可视模式下）：选择从当前位置到上一个空白行（段落的开头）的文本。

    }：将光标移到下一个空白行（段落的开头）。   
    2}：将光标移到下两个空白行（两个段落的开头）。
    }（在可视模式下）：选择从当前位置到下一个空白行（段落的开头）的文本。

    H 移动光标到窗口首行
    M 移动光标到窗口中间
    L 移动光标到窗口尾行
    gg 移动光标至第一行
    G 移动光标到最后一行
    n% 跳到整个文件的百分比位置
    数字 + gg, 表示跳转到文件的第几行
    数字 + G, 也表示跳转到文件的第几行。
    数字 + L, 移动到窗口的倒数第几行
    数字 + H, 移动到窗口的第几行
    数字 + M, 与单纯的使用M 效果一样
    

3.3. 结合跳转指令的操作

    例1: 假设光标在 relativenumber 的词首,将其变为number，有下面方法：
        . 使用cw 来删除该单词并输入number
        . dtn 来删除字符 n 前面的部分 
        
    例2: 将 word = "hello world!!" 改为 word = "hello world!!!"
        . 使用 2f! 将光标移动到对应位置，然后使用 a 进入插入模式插入对应字符
        . 使用 2f" 移动到行尾，然后使用i 进入插入模式插入对应字符
        . 使用$ 跳转到行尾，使用 i 进入插入模式进行修改

    例3: 将 greet = “hello world” 改为 greet = “nice to meet you”, 光标位于h处
        . 使用 d2w 删除两个单词并进入插入模式
        . 使用 dt" 删除对应单词，然后进入插入模式
        . 使用 ci" 删除对应字符并进入插入模式

3.4. 文本对象

    下面给出各种文本范围：

        w	    word 词
        s	    sentence 句
        p	    paragraph 段
        t	    tag(HTML/XML) 标签
        [或]	由[]包裹的部分
        (或)	由()包裹的部分
        <或>	由<>包裹的部分
        {或}	由{} 包裹的部分
        "	    由""包裹的部分
        '	    由''包裹的部分
        `	    由``包裹的部分
    例如：
        greet  = <hello world>
        greet  = (hello world)
        greet  = [hello world]
        better = {hello world}
        better = `hello world`
        greet  = 'hello world'
        better = "hello world"
    光标位于h或前面，删除或复制等操作包裹的内容。
    可以使用如下命令：

    di"包裹字符" 
    或ci"包裹字符" 
    或yi"包裹字符"等，

    i操作包裹字符内部的文本，若把i 换成a则连同包裹字符一同操作。
    操作包括删除、复制等。
    包裹字符是上面的的括号及引号，如：<> , (), {}, "", '', ``, <>等。
    () 可以用 b 代替，{} 可以用 B 代替


    假设有这么一段文本

        <div class = "example">
            <div> This is vim example</div>
        </div>
    我们希望将其变为

        <div class = "example">vim is so good </div>
    我们将光标移动到最外层的div上，然后使用 cit 删除div中的内容，然后输入 “vim is so good”。
    cit：c是操作符“替换”，it是取“文本对象”，这个文本对象是当前光标所在标签的内容，并不是指标签本身

==============================================================
                    4 '.' 命令
==============================================================

4.1 .  重复上次修改

    例1：
        if user == "vim":
        print("vim is best!") 
        else: 
        print("vim is not best")

    2行和第4行进行缩进：
        j 移动光标到第2行
        >> 缩进代码
        2j 跳转光标到第4行
        使用 . 重复上一次修改

4.2 如何定义上次修改

    不同的编辑器对上次修改的定义不同，
    有的可能是词、句子、段甚至有的可能按照输入时间来算，
    一段时间内的输入算作上次修改，
    而vim可以自己定义上次修改范围是多少。

    vim一般将从进入插入模式开始，
    到从插入模式退出这段时间内做的修改做为上次修改，
    或者在普通模式下将我们使用一次
    operat = operator + motion 公式作为一次修改

    例子2：
        例如我们有这么一段话
        this is no more one line 
        this is no more one line

        光标移动到 第一个n 处，使用d2w 删除两个单词，
        j 移到下一行， 
        使用 . 执行与上一行一样的操作

    在进入插入模式时，连同进入插入模式的操作一起，
    与在插入模式下输入的内容一同被算作上次修改。
    例子3：
        this is only one line 
        this is only one line

    改为

        this is no more one line 
        this is no more one line

    光标移动到 only 的首位，然后使用 cw 进入插入模式，
    输入 no more 退出输入模

    用j 移动到下一行，再使用 2b 移动到第二行同样的位置，
    最后使用 . 来重复

    上一次修改仅限于进入插入模式的一次操作，
    而之前进行的移动光标之类的操作就不再统计为一次修改。

    例子4：
    有这么一段代码

        var foot = "foot" 
        var ball = "ball" 
        var football = foot + bar

    我们要在每行的后面加上一个分号。
    方案一：用 $移动光标到行尾，然后使用 a 插入模式，接着添加一个分号，退出插入模式
            j 移到下一行
            . 重复输入分号动作，不包括移动行尾的动作，不能达到目标，要先手动的调整光标位置

    方案二：使用 A 在行尾进入插入模式，输入后续移动光标的步骤


4.3 复合命令

    复合命令	等效长命令	        含义
        A	        $a	    在行尾进入插入模式
        I	        ^i	    在行首进入插入模式
        o	        A<CR>	在下一行进入插入模式
        O	        ko	    在上一行进入插入模式
        S	        ^c$	    删除当前行并进入插入模式
        C	        c$	    删除当前光标位置到行尾的内容并进入插入模式
           s	        cl	    删除光标后的一个字符并进入插入模式

总结： . 命令，它能重复上次修改。但是需要注意以下几点：
        上次修改是从进入插入模式开始，到回到普通模式为止这段时间内做的修改，
        或者在普通模式下使用一条命令进行的修改
        . 命令并不关心上次修改的位置，只会简单的重复上次修改。
        所以在使用前尽量考虑该使用哪些命令能最大限度的让. 重复更多操作。
        使用复合命令不光能减少输入字符数，配合. 命令将产生强大的效果。

==============================================================
                        5 普通模式的一些操作
==============================================================

5.1 快速翻阅文本
        ctrl + f: 向下翻页
        ctrl + b: 向上翻页
        zt: 将光标所在行移动到窗口顶端
        zb: 将光标所在行移动到窗口底端
        zz: 将光标所在行移动到窗口中央
        H 移到当前屏幕的首行首列
        L 移到当前屏幕的尾行首列
        M 移到当前屏幕的中行首列


        ctrl+f/d    下移一屏/半屏
        ctrl+b/u    上移一屏/半屏
        ctrl+e      下移一行
        ctrl+y      上移一行

        <C-O>：返回上一步//<C-o>也可以
        <C-I>：下一步，即对于<C-O命令的逆转>//<C-i>也可以
        <C-]>：jump to tag
        <C-T>：pop tag：标签退栈

5.2 撤销
        撤销在普通模式下使用 u，反撤销使用 Ctrl+r。
        vim的撤销是撤销上次修改，结合之前介绍的. 命令的部分，
        我们可以知道，
        上次修改指的是从进入插入模式那一刻起到退回到普通模式为止，
        进行的一系列的修改。
        根据这个特征，我们可以很方便的定义撤销哪些内容。
        例如在写这篇文章的时候我进入插入模式进行编写。
        然后在需要构思的地方退回到普通模式，
        想到了一些再次进入插入模式编辑，
        一旦发现有问题就可以在普通模式下撤销上次的修改。

        例子1：
            我们先使用 cw 替换一个单词，然后删除一行。
            使用u 恢复上一次的修改，也就是恢复删除的一行。
            使用 ctrl + r 执行反撤销，即再次删除上次恢复的一行。
            u 和 ctrl+r 是操作符，
            它们符合之前介绍的 
            operat = 数字 + operator的公式，
        因此如果想要恢复到最开始的状态，可以使用 2u。

5.3 普通模式下对数字文本进行递增递减操作
    使用 Ctrl + a 来在数字文本上进行递增操作，
    它也是一个操作符，符合之前的公式。
    这里假设光标在 5 的位置，
    然后执行 5 Ctrl+a 来实现将5这个数字文本递增5个的操作。
    递减操作使用 Ctrl x。

    几种情况说明:
        如光标不在数字所在位置，Ctrl+a会在本行往后查找第一个出现的数字，并将光标跳转到该处，然后执行操作。
        有不止一个位置有数字，光标也不在某个具体数字上，执行Ctrl + a 会跳转到第一个数字并操作。
        当前行没有数字，在后面几行有数字，执行Ctrl a 不进行操作。




    

==============================================================
                    6 插入模式
==============================================================

6.1 进入插入模式的一些命令

    命令	            含义
     i	        在当前光标前进入插入模式
     I	        在行首进入插入模式
     a	        在当前光标后面进入插入模式
     A	        在行尾进入插入模式
     o	        在下一行进入插入模式
     O	        在上一行进入插入模式
     s	        删除当前光标所在字符并进入插入模式
     S	        删除光标所在行并进入模式
     c+motion   删除指定范围的字符，并进入插入模式
     C	        删除光标所在位置至行尾的字符，并进入插入模式

6.2 在插入模式中删除字符
    如果要删除的字符刚好在光标前面，我们可以使用退格键删除它。
    另外vim提供了其他几种方式在插入模式中向前删除单词、行。

    <Ctrl + h>: 删除光标前一个词(与退格键相同)
    <Ctrl + w>: 删除光标前一个单词
    <Ctrl + u>: 删除至行首
    
    
6.3 插入-普通模式:Ctrl + o
    从插入模式返回到普通模式可以使用 \<Esc\> 键，或者使用 <C-[>

    假设光标已经到窗口的最后一行了，若将光标定位到窗口中央，
    一般都会先退回到普通模式，然后使用 zz来完成这一动作，最后再进入插入模式。

    针对这种情况vim 提供了一种新的模式：
    .插入—普通模式。
        在插入模式中使用Ctrl + o 来进入该模式。
        该模式运行用户暂时回到普通模式，
        然后在执行一条普通模式的命令之后自动回到插入模式中。

6.4 插入非常用字符

    <Ctrl + v> {code}：按照字符的十进制编码输入，这里code只能输入单字节的字符
    <Ctrl +v> u{code}: 按照字符的16进制编码输入，这里可以支持两个字节的字符输入，例如unicode
    <C-k>{char1}{char2} 来输入二合字符，要输入分数 1/2可以使用
    <C-v>12 来进行
    可以在vim中使用 
    :h digraph-table 来查看二合字母表
    例子1 ：
    用该方式输入字符A，在插入模式下使用 <Ctrl v>65 然后回车即可
    例2：
    输入安卓小机器人，查询unicode字码表，它的16进制值是 e70e，那么我们就可以输入<Ctrl v>ue70e

6.5 替换模式
        vim 中的替换模式与改写模式类似。
        它会将光标所在字符替换为新输入的字符，
        按照 vim官方文档的说法，替换模式不会变更文本自身的长度，只会在现有长度上替换已有文本。
        只有在光标超出原有文本长度时才会表现出插入字符这一特性。
        而且在替换模式下没有删除的操作。

        在某些情况下替换可能会导致代码格式错乱，
        如果代码中某些位置存在制表符，
        而制表符的宽度会根据tabstop 的值不同，而显示不同，
        例如vim 默认的制表符占8个空格，
        如果我们使用R 进入替换模式，替换tab键的话，
        原来的tab键所有空白字符都会被替换，
        这样会导致文本长度发生变化。
        如果不希望长度变化，
        vim提供了一种被称之为虚拟替换模式的方式，
        可以使用 gR 进入，这样再替换制表符的话，
        制表符被替换为一个字符+ 多余的空格，源文本长度不变。

        6.5.1 使用普通替换模式：R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)
        6.5.2 使用虚拟替换模式：gR进入虚拟替换模式

        6.5.3 如果只是想替换一次，
            可以使用r{char} 和 gr{char} 暂时进入替换模式，
            替换一个字符后立即回到普通模式

        6.5.4 修改配置文件解决tab问题
            至于虚拟替换模式解决tab 的问题，
            我更喜欢使用一些配置将tab 键改为空格，
            这里我们在配置文件中再添加几行

        -- nvim lua 配置 
        vim.o.softtabstop = 4 
        vim.o.shiftwidth = 4 
        vim.o.expandtab = true


        # vimscript 
        set softtabstop=4 
        set shiftwidth = 4 
        set expandtab = true

        这几行会将tab替换为4个空格，
        并且在一些代码中，如果加入了自动缩进的属性，
        在输入下一行的时候它会自动以4个空格进行缩进
            
    

==============================================================
                    7 可视模式
==============================================================

7.1 vim中有3种可视模式，分别用来处理不同范围的文本：
    处理字符的可视模式
    处理行的可视模式
    处理列块的可视模式
    普通模式中，输入v进入可视模式。

    vim的可视模式,先选区,然后对选区进行操作。
    选区时可以使用之前介绍的motion 来移动光标进行选区，
    操作选区的时候可以使用 operator 进行。

    可视模式下操作的逻辑与在普通模式下的操作逻辑不太相同，
    可视模式下先使用motion 移动光标选中部分内容，
    然后调用operator 来对选中部分做操作。

    普通模式下先调用 operator 声明需要进行的操作，
    再使用motion 传入要操作的文本范围。
    但是可视模式下的操作逻辑确与一般的文本编辑器类似，
    都是现选中一个部分，然后再针对这部分进行操作.

    例1：我们将 there is one more line 改为 there is one line。
        操作：光标移到m，v进入可视模式，e选择单词more，d删除所选。

7.2 选择模式
    在一般的编辑器中，选中一段文本后，
    输入任意字符会先删除选中部分然后再插入输入的字符，
    但是vim的可视模式并没有这么做。
    从上面的例子也可以看出来，
    vim的可视模式保持了普通模式中使用操作符操作区域的逻辑。
    但是vim也提供了类似于普通编辑器一样的体验，这个体验就是选择模式。

    在进入可视模式后，使用<Ctrl +g> 进入选择模式，
    此时左下角的字样已经变为 SELECT，表示此时进入了选择模式。
    在选择模式中，随便输入一个字符，它会删除选中然后输入对应的内容。

7.3 可视模式的3种子模式

    7.3.1 处理字符可视模式:普通模式下按v进入，与普通的motion 配合，选中光标移动所经过字符。
    7.3.2 处理行的可视模式:普通模式下按V进入，与行操作motion 配合，一次选中一行。
    7.3.3 处理列的可视模式:普通模式c-v进入，与motion 配合，一次选中一列，行操作选多列，hl 选中多列。

    3种模式下可以互相转化，按键与上面介绍的相同。
    但是如果处在处理字符可视模式下再次按下v 则会退回到普通模式，
    在其他模式下类似,即连续两次进入同模式退出。

7.4 重新选择选中区域
    选错重选方式：
        .退回到普通模式下，然后再重新进入选择模式。
        .按o重新选择选区的活动段。
            选择模式下选区一段固定，另一端可以移动。
            通过多次按下o来变更需要移动哪一段

7.5 可视模式下的新命令—
    gv 它可以跳到上次选中的区域并选择。

示例1：缩进Python代码

    假设有这么一段Python代码

        def fib(n):     
            a , b = 0, 1 
            while a < n: 
        print(a) 
        a , b = b, a + b 
        fib(42)
    要将中间两行缩进两次，变为下面的代码

        def fib(n):     
            a , b = 0, 1 
            while a < n: 
                print(a)         
                a , b = b, a + b 
        fib(42)

解法1：可以在普通模式下，在对应位置使用 2>> 将两行缩进一次，然后使用 .命令再重复一次
解法2：使用>j 缩进两行，然后使用 . 重复，效果与上面的解法1一样，这里就不演示了
解法3：使用 V 选中一行，然后使用2> 缩进2次，移动到下一行后使用 .重复
解法4：使用V 选中一行，然后使用j 再选中一行，接着使用2>> 将选中两行一次缩进两次
解法5：先选择两行,再使用> 缩进一次，然后使用 gv 选中上次选中的两行，再次使用 >

需要注意：在基于字符的可视模式下 . 命令操作的字符数与上次修改中操作的字符数相等。
例如：
        world 
        world1 
        world11 
        world111
当我们在第一行使用 v 进入选择模式，然后使用e 选中一个单词删除它之后，
再在下一行执行. 命令的时候，并没有删除一行，只删除了world这个单词。
如进入处理行的可视模式，删除包括了换行符，不会出现这种情况。

在处理一次性操作的任务时，vim的可视模式在效率上于普通模式其实差距不大，而且有时候要修改的文本所在区域无法准确的通过一两个motion 表达出来，这种情况下可视模式就大大的派上用场了。下面几个列子就可以说明这点。

例子2:处理列的可视模式的初步使用
    假设我们要将下列代码'P'变为'p'.

        Print("hello world") 
        Print("hello world") 
        Print("hello world") 
        Print("hello world") 
        Print("hello world")
操作：进入列的可视模式，选中所有的P，用 u 将其变为小写.

示例3：添加注释,即行首添加'#'
假设现在有一些Python代码需要添加注释，
    print("hello world") 
    print("hello world") 
    print("hello world") 
    print("hello world") 
    print("hello world") 
    print("hello world")
操作：进入列的可视模式，选所有的p，
    用 I 在行首进入插入模式，
    输入 # 注释代码，
    <Esc> 退回到普通模式，
    我们可以看到在插入时它只显示了一行的变化，
    回到普通模式后，第一行的变化作用到了所有选中行。

示例4：行尾添加';'
假设现在有一些代码行尾需要添加';'
    print("hello world") 
    print("hello world") 
    print("hello world") 
    print("hello world") 
    print("hello world") 
    print("hello world")

操作：光标移动到第一行的最后一列，进入列可视模式，移动光标到最后一行的行尾。
    用A 进入插入模式，输入分号，
    最后使用<Esc> 回到普通模式。
    这个时候我们发现vim在被选中区域每一行的尾部都添加了一个分号




在普通模式下 i I a A 都有自己的用途，
而在处理列的可视模式下我们都只是在用 I 和 A ，
而且他们的含义与在普通模式下有所不同，
在处理列的可视模式中，
A: 表示在"选择区"的每个行尾进行同样的操作，
I: 表示在"选择区"的行首进行同样的操作。
是"选择区"的行首或行尾，不是整行的行首或行尾。
至于a 和 i 这里则代表要处理的文本对象。

选择单词：
viw：选择当前光标下的单词，包括单词两边的空白字符。
    一旦选择完成，你可以执行各种操作，
    如复制（按 y）、删除（按 d）、替换（按 s）、缩进（按 > 或 <）等。

选择句子：
    vis：选择当前光标所在的句子。
    visn：选择下一个句子。
    visN：选择上一个句子。

选择段落：
    vip：选择当前光标所在的段落。
    vipn：选择下一个段落。
    vipN：选择上一个段落。

选择括号内的文本：
    vi(：选择当前光标所在的圆括号内的文本。
    vi[：选择当前光标所在的方括号内的文本。
    vi{：选择当前光标所在的大括号内的文本。

选择标签内的文本（适用于 HTML/XML）：
    vit：选择当前光标所在的标签内的文本。

选择引号内的文本：
    vi"：选择当前光标所在的双引号内的文本。
    vi'：选择当前光标所在的单引号内的文本。



eg：vim如何对多行双引号中的内容进行多行一次性替换？
    将原来双引号中的内容 plant, tree, grass, flower， 
    直接一次替换成 animal dog, fish, elephant。

    如下：
        System.out.println("plant");
        System.out.println("tree");
        System.out.println("grass");
        System.out.println("flower");

        animal
        dog
        fish
        elephant
    改为：
        System.out.println("animal");
        System.out.println("dog");
        System.out.println("fish");
        System.out.println("elephant");

way1:分屏加宏 （适用场景多，中间结果清晰，推荐）//相当于把新单词放在新屏，然后跨屏复制
    1. :vnew 分屏
    2. 将animal......elephant复制到新屏
    3. 分别将两屏光标移到待处理文本的起始行、起始列,最后光标位于新屏。
    4. "qq"开始宏录制
    5. "0yw^Wwf"wviwpj^Wwjq"。
        0:   移到行首
        yw:  复制单词,yiw更好
        ^Ww: 切换屏
        f":  查找"
        w:   跳到下一单词
        viw: 选择单词
        p:   替换选择的单词
        j:   跳到下一行 
        q:   结束录制。
        跳到下一行要在当前行处理完毕后执行，
        防止跳转失败导致当前行未处理。
    6. 跳转到首行或者下一行执行“10@q”
        可以:let @t="@q@t" 这样循环执行
        或者 录制宏的时候，最后加一条"@q"，变成：
        "0yw^Wwf"wviwpj^Wwj@qq"。
        @q：表示执行宏，这样执行的时候就不用加执行宏的次数即可自动执行。
way2:相对行号加宏 （适用于行数较少的情况）//相当于直接从原来位置复制新单词
    1.计算新内容所在行与被替换行差值，假如为N
        可以直接计算，也可以:set relativenumber 直接显示相对行号
    2.移动到待替换首行首列
    3.qq开始录制宏
    4."0NjywNkf"wviwpj"
    ......

way3:相对行号加t命令加宏 （方案二的变种）//相当于把新单词放在下一行，复制完后删除该行
    1. 移动到待替换首行首列
    2. qq开始录制宏
    3. "0:+5t.^Myiwkf"wviwpjdd"
        :+5t.   :将后面第5行的内容复制到当前行下面光标也被移到下一行了
        ^M      :回车
        yiw     :复制单词 
    4.执行宏有两个方式：
        V进入行可视模式选择待替换的所有行，执行
        :'<,'>normal @q 或者直接 N@q

way4: Visual Block加norm命令//相当于把新单词放在行首或行尾。
    此方法就是将新的单词放到每个待替换行的行首或行尾。
    放到行首或行尾时，要与原来的行有空格间隔，方便后面操作。
    所以，首先要在行首或行尾添加一个或多个空格。
    (结合上面具体文本理解下面的内容)
    //把新单词放在行首
    1.  复制新内容：
            先移动到待复制块的起始位置，
            ctrl+v, 进入列可视模式，选择待操作的行，e选择文本到单词尾。
            注意：复制内容的末行不能包括换行符，否则后面块操作失败，
                故保证选择块的最后一行(如果向上选择，最后一行是第一行)单词最长，否则不能选择所有内容。
                如果单词结尾也是行结尾可以用$,到行尾，这样就不必要求行尾单词最长。
                也可以列选择模式，先复制前面的内容，最后一行yiw追加到寄存器。
                //实验发现yiw追加到寄存器不可以。         
    2.  行首添加空格：
            ctrl+v，进入列可视模式，选择待操作的行.
            I 进入插入模式，光标移到行首，输入空格，退出可视模式。
                注意：无论k选择或者j选择，A与I，进入输入模式，都是在行号最小的行输入。
            P 黏贴，当前光标在空格处，要黏贴在空格前面，所以用大写P。
    
    3.  shift+v选中待处理的行，然后进入命令行模式
        ":'<,'>normal diwf"wviwp0dw^M"
    //把新单词放在行尾 
             
    
    1.  复制新内容：
            先移动到待复制块的起始位置，
            ctrl+v, 进入列可视模式，选择待操作的行，e选择文本到单词尾。
            注意：复制内容的末行不能包括换行符，否则后面块操作失败，
                故保证选择块的最后一行(如何向上选择，最后一行是行号最小行)单词最长，否则不能选择所有内容。
                如果单词结尾也是行结尾可以用$,到行尾，这样就不必要求行尾单词最长。
                也可以列选择模式，先复制前面的内容，最后一行yiw追加到寄存器。(好像不行)
                //实验发现yiw追加到寄存器不可以。
    2.  行尾添加空格：
            a. 光标处于首行，然后$，处于末列。
            b. ctrl+v，进入列可视模式，选择待操作行.
            c. A进入插入模式，光标移到行尾，输入若干空格，使最短行的长度加上空格大于最长行长度。
            d. 退出输入模式。
                注意：无论k选择或者j选择，A与I进入输入模式，都在最小行输入。
                        所以，可以让行号最小行最短。
            e. 重复a、b、c操作，直到选择块与每行都有空格。
            f. p黏贴， 

    3.  shift+v选中待处理的行，然后进入命令行模式
        ":'<,'>normal $diw0f"wviwp^M"    

way5: substitute命令 
        ":%s/"\zs.*\ze"/\=getline(line('.')+5)/g^M"
            line('.')：当前行号
            getline();行号所在的文本
        ":%s/\v(plant|tree|grass|flower)
            /\={'plant':'animal','tree':'dog','grass':'fish','flower':'elephant'}[submatch(1)]/g"

            (plant...)：这是一个正则表达式，它匹配四个可能的单词之一。
            \={'plant':'animal'...}：
                这是一个 Vim 字典，它将匹配的单词映射到对应的值。
            [submatch(1)]：
                这是一个表达式，它使用 submatch(1) 来获取正则表达式捕获组 1 中的匹配内容，即匹配的单词。
            \={'plant':'animal'...}[submatch(1)]
                大括号是映射字典，[]匹配的单词，二者结合的结果是映射值


        关于vim字典使用的eg：
            :let r={'a':'A', 'b':'B', 'c':'C', 'd':'D', 'e':'E'}
            :%s/\v(a|b|c|d|e)/\=r[submatch(1)]/g

总结各个方法：
    substitute命令，
    宏操作，
    normal命令，需结合块视图操作。
    块视图操作，需要结合其它命令。
    
    
==============================================================
                    8 使用命令模式编辑文本
==============================================================
8.1 命令模式简介
    普通模式下，按下: 切换到命令行模式，
    这个时候vim会等待我们输入一个命令,最后以回车(<CR>) 结束输入并执行

    在命令行中的操作与在插入模式中类似，只是插入模式会将键盘输入写入缓冲区，
    而命令行模式则会将输入显示在命令行位置。
    二者的操作符也类似，例如可以适用 
    <Ctrl-w> 和 <Ctrl-u>：删除至上个单词的开头和行首。也可是使用 
    <Ctrl-v> 和 <Ctrl-k>：输入键盘上找不到的字符。
    也可是使用方向键来移动光标，或者使用退格键删除命令。
    如果中途不想执行输入的命令，可以使用<Esc> 退回到普通模式。 
    :print ，它会打印当前行。

8.2 配合范围使用命令
    command = {startpoint},{endpoint} + cmd
        其中 startpoint 表示开始位置，绝对地址，
        endpoint表示结束位置，绝对地址，
        他们中间用,隔开，
        后面紧跟着一个命令。
        如果不加范围，则表示操作的范围是光标所在行，
        例如 :print 表示打印光标所在行的文本

        如果只输入一个数字，
        vim会首先将光标移动到对应的行上，
        然后针对该行文本执行操作，
        例如如果输入 :2print 它会将光标移动到第二行，
        然后对第二行文本执行打印操作。

8.3 使用数字代表对应行
    :3,5d enter 删除第3到第5行范围内的文本.

8.4 使用特殊符号代表对应行
        .: 当前行
        $: 文件末尾
        0: 虚拟行，位于文件第一行的上方
        1: 文件第一行
        'm: 包含标记m的行
        <: 高亮选区的起始行//实际操作是：'<
        >: 高亮选区的结尾行//实际操作是：'>
        %: 整个文件，相当于 :1,$

    介绍了这些操作符之后，如果我们需要删除整个文件，那么有这么几种方法
    方法1：普通模式下，使用 1 跳转到第一行, 然后使用dG 第一行到最后一行的内容
    方法2: 命令模式下，使用 :1,$d 删除第一行到最后一行的内容
    方法3: 命令模式下，使用 :%d 删除所有

8.5 使用位置偏移量来微调操作范围
    在 {startpoint}, {endpoint} 中二者均为绝对地址，
    除了使用绝对地址，我们也可以使用
    绝对地址+偏移地址的方式来定义操作范围。
    可以在绝对地址上使用 + 或者 - 来定义如何进行偏移，
    例如 $-3 会定位到倒数第4行。
    :4,$-3d保留前3行和后3行

8.6 将可视模式的选区作为操作范围
    在选中一个选区后，按下: ，在左下角会出现 <,> 的字样，根据前面的列表知道 他们代表的是被选中的高亮选区。
    :'<,'> 表示选中区域
    :'<-1,'>+2d也可以删除指定范围

8.7 其他操作文本的命令
    在上面的例子中，我们主要使用了 d 这个命令来删除文本，
    除了它还有其他一些处理文本的命令，
    这里我以 t (拷贝粘贴) 和 m （移动）为例，其它命令类似。

    8.7.1 使用t命令
        t 命令代表拷贝和粘贴，可以理解为 CopyTo.它的形式如下:
            :range + t + address
        range   代表粘贴的文本范围，address 代表粘贴内容放置的行号

例子：
    :7t5 第7行的内容复制到第5行下方
    :48,54t43 将48到54内容复制到43行下面

    :7m5 第7行的内容剪切到第5行下方
    :48,54m43 将48到54内容剪切到43行下面

8.8 文本操作命令

    命令	简写	用途
    :[range]delete [x]	d	删除指定范围内的行[到寄存器 x 中]
    :[range]yank [x]	y	复制指定范围的行[到寄存器 x 中]
    :[line]put [x]	pu	在指定行后粘贴寄存器 x 中的内容
    :[range]copy {address}	t	把指定范围内的行拷贝到 {address} 所指定的行之下
    :[range]move {address}	m	把指定范围内的行移动到 {address} 所指定的行之下
    :[range]join	j	连接指定范围内的行
    :[range]normal {commands}	narm	对指定范围内的每一行执行普通模式命令 {commands}
    :[range]substitute/{pattern}/ {string}/[flags]	s	把指定范围内出现{pattern}的地方替换为{string}
    :[range]global/{pattern}/[cmd]	g	对指定范围内匹配{pattern}的所有行，在其上执行Ex 命令{cmd}

8.9 范围符号

    符号	用途
    .	当前行
    $	文件末尾
    0	虚拟行，位于文件第一行的上方
    1	文件第一行
    'm	包含标记m的行
    <	高亮选区的起始行//实际操作是：'<, 是起始位置
    >	高亮选区的结尾行/实际操作是：'>，是结尾位置
    %	整个文件，相当于 :1,$

总结一下主要内容

    .命令模式是vim中又一重要的模式，使用率不亚于普通模式
    .命令可以配合数字或者其他符号使用，代表将要操作的文本范围
    .主要以 t 和 m 命令介绍了操作文本命令的用法
    .最后再给出一些命令和范围的总结供大家查阅

==============================================================
                    9 命令模式进阶
==============================================================
9.1 命令行模式下使用普通模式的命令
    
    .命令没有类似 数字 + . 以达到重复执行目的。
    之前的例子只有3行，每次使用. 之后使用j 来移动然后再使用. 
    代码少，手动移动行，也可以。但是如果代码行较多呢？
    问题1：如何将有几千代码行的尾部都加分号？
   
    针对这个问题，可以有不同的解决方案，
    在学习. 命令的时，可以使用. 命令解决，
    在学习可视模式的时，可以使用处理列的可视模式解决。
    在命令行模式中使用normal 关键字使用普通模式的命令，也能解决。

    它使用的方式为：range + normal + operator ，
    它支持范围操作，表示我们将要针对某个范围来执行普通模式的操作。
    normal方法解决问题1：
        normal操作1：
            1.普通模式移动到首行，按下A，进入插入模式，输入“;”，
                构造可以使用.命令的操作。
            2.命令行模式，输入2,$normal. (normal后空格可以无)
        normal操作2：
            命令行模式，输入%normal A; (normal后空格必须有)

    normal 后面不仅仅是operator，
    也可以跟一些改变当前模式的命令并且可以指定输入的内容。
    快速删除一个文件的方法：
        方法1：命令行模式的操作：%d
        方法2: 命令行模式的normal：%normal dd

9.2 重复上次的ex命令(ex命令可以理解成是命令行模式的命令)
    普通模式重复上修改可以使用 . 命令。
    但是，非修改命令就不能重复，
    而且 . 命令也不能修改由ex命令造成的修改
    @: 命令可以重复上次的ex命令。
    如果执行过 @: 进行重复，那么可以使用
    @@ 再次执行上次重复的命令。
    例子：编写代码时经常会一到的一个问题就是将当前行代码下移一行，
        但是也不是所有的行都会这么干，那么就可以先使用
        .m.+1将当前位置的代码移动到光标的下一行，
        在下一个需要这次操作的位置执行 @: ，
        如果还有位置需要次操作，可以直接使用 
        @@ 来重复上一次的操作了。连按两下@比按@:要快。
    .  主要用于普通模式修改命令的重复
    @: 主要用于ex命令的重复。

9.3 自动补全ex命令
    vim在使用tab时会自动检索之前输入的历史进行匹配。
    例如，使用 :
    %n<tab>。它会匹配到一堆符合要求的命令。多次按下 
    <tab> 键则会依次按从上到下的顺序进行匹配。也可以使用 
    <Ctrl n> 和 <Ctrl p>跳转到下一次匹配和上一次匹配。同样的也可以使用 
    <Shift Tab> 来跳转到上一次匹配.
    :h wildmode 和 :h wildmenu ，用来来查看对应的帮助文档，下面是一种配置
            -- lua配置
            vim.o.wildmenu = true 
            vim.o.wildmode="full"

            # vimscript
            set wildmenu 
            set wildmode=full

9.4 回溯命令历史 //下面的操作同样适用于后面介绍的搜素模式
    按下 : 进入到命令模式之后，
    可以使用方向键向上或者向下查找历史命令。
    除了使用 方向键以外，还可以使用 
    <Ctrl p> 和 <Ctrl n> 来遍历，
    但是使用方向键有一个好处是他们可以针对之前已经输入的内容对匹配的内容进行过滤。
    坏处在于，手指的移动幅度大，我们可以使用映射的方式将
    <Ctrl p> 和 <Ctrl n> 进行映射。


    查看历史记录可以在命令行用 <c-f>或者普通模式用 q:(q/,可以查看搜索历史记录)。
    历史记录可以向普通文本一样用普通模式的命令操作。
    在历史记录中选中命令并进入命令行用 <c-c>。
    退出查看历史记录模式：先进入命令行模式，然后esc退出。也可以直接连续两次按 <c-c>。
    历史记录与命令行相互切换用<c-c>和<c-f>
    在命令行输入命令时，按tab可以自动补全命令，继续按tab则可以选择其它自动补齐命令。


9.5 运行shell 命令
    9.5.1 shell命令前加!,可以在命令模式执行shell命令
        在vim的命令模式中也可以执行shell命令。
        只需要在shell命令前面加上 ! 即可，
        例如执行 :!ls 将会执行ls 这个命令
        如果我们在当前编辑的文件内，直接执行:r!date；就能把时间直接打印到当前光标处！
    9.5.2 %代表文件名传参
        在vim的命令模式中，% 代表的是当前文件名，
        在运行某些可以传入文件名作为参数的命令时，可以使用它，
        例如我要执行当前的Python代码时可以使用 :!python %
    9.5.3 命令模式中的范围作为shell命令输入
        我们也可以将vim命令模式中的范围配合shell命令使用，
        这个时候范围中包含的内容将会作为shell命令的输入, 

        例如现在有这么一个文件，记录了一个文件列表，
        现在我想要按照文件名排序。
            files: 
            a.txt 
            ccc.txt 
            b.txt 
            d.txt 
            z.txt 
            t.txt
        可以配合sort 使用 
        :2,$!sort,
        由于第一行是表头的文字不进行排序，
        所以这里从第2行开始参与排序。

9.6 使用 write 和read 命令重定向vim缓冲区内容
    在vim配合shell命令使用的时候有时候shell会产生大量是输入或者需要一定的输出，那么就可以使用 write 和 read 来配合shell使用。
    read：vim从shell产生的输出中读取内容写入缓冲区
    write: vim将缓冲区的内容写入到shell中，作为shell的输入
    例如：某个文件中有大量的Python代码，
    但是我只想执行部分，那么可以配合write使用，

    例如3,5write !python 执行文件中3-5行的Python代码，
    或者配合可视模式，执行选中的代码。
    再比如，我现在需要获取当前目录下有多少个文件和目录，
    并且按照文件名顺序排列，就可以使用 
    :read !ls|sort。

    甚至配合键绑定，完成ide那种一键自动编译运行的效果。
    例如：
    vim.api.nvim_set_keymap('n', '<F5>', ':write | !python %<CR>', {noremap = true, silent = true})

    除了手工填写范围配合shell命令之外，
    vim提供了一种简便的方式来完成这一工作，可以使用 
    !{motion} 来快速形成范围，后面只需要输入命令即可。
    针对前面排序文件的例子，假设光标在文件的第二行，
    可以使用在普通模式下输入
    !G 来快速选中整行，
    vim为我们在右下角填充了
    :.,$! 后面只需要写上sort 之后就可以了

    查看历史记录可以在命令行用 <c-f> 或者普通模式用 q:，选中命令按 <c-c>

==============================================================
                    10 缓冲区列表
==============================================================

10.1 缓冲区列表简介

    将文件从磁盘读取到内存中时，
    都会事先分配一块内存缓冲区用来保存读取到的文件内容，
    vim同样是这么干的。

    vim在读取文件时会通过内存映射的方式，
    将磁盘中的内容映射到一块内存的缓冲中。
    vim可以打开多个文件，每个文件独立的占有一个缓冲区。
    为了管理这些打开的文件，vim中有了缓冲区列表的概念，
    同时也提供了一些配套的命令来操作缓冲区列表。
10.2 打开多个文件显示信息
    某个目录中有多个文件，
    我们使用vim同时打开，
    例如使用vim init.lua test.py。
    vim默认只展示一个文件中的内容，
    但是它打开了两个文件，
    现在有两个以文件名命名的缓冲区。
    通过命令:ls 查看当前打开的缓冲区。
    :ls 命令显示的内容每一行代表一个缓冲区的信息。
    它显示的信息如下：

        :ls   
        1 %a   ".\test.py"                    line 1   
        2      ".\init.lua"                   line 0

        下面是我自己操作的例子：
        :ls
        1 %a   "a.py"                         line 31
        2      "b.py"                         line 0
        3      "c.py"                         line 0
        4      "a.md"                         line 0
        5      "b.md"                         line 0
        6      "c.md"                         line 0
        7      "a.c"                          line 0
        8      "b.c"                          line 0
        9      "c.c"                          line 0

      第一列的数字代表缓冲区的编号，该编号由vim随机指定，
      第二列的%a 代表缓冲区为激活的缓冲区(active)当前窗口显示的内容为激活缓冲区的内容。
      第三列则是缓冲区的名称，一般vim会将文件名作为缓冲区的名称
      第四列则是缓冲区光标所在的行号，为0说明未激活过。

10.3  操作命令如下：
      :bnext 按:ls 的显示顺序，显示下一个缓冲区，
      :bprev 显示上一个缓冲区。
      :blast 显示最后一个缓冲区，
      :bfirst显示第一个缓冲区。
      :e file2 命令加载另一个文件

      在切换过缓冲区之后再次执行:ls 之后发现此时显示的内容已有一些变化。
      现在显示的内容如下:

        :ls   
        1 #h   ".\test.py"                    line 1   
        2 %a   ".\init.lua"                   line 1

        下面是我自己操作的例子：
        :ls
        1      "a.py"                         line 31
        2      "b.py"                         line 0
        3 #    "c.py"                         line 20
        4      "a.md"                         line 0
        5 %a   "b.md"                         line 1
        6      "c.md"                         line 0
        7      "a.c"                          line 0
        8      "b.c"                          line 0
        9      "c.c"                          line 0

        此时我们发现除了
        %a 代表当前处于激活状态的缓冲区外，另外一个缓冲区的前面多了个
        #h ，# 代表上一次处于激活状态的缓冲区，h 则代表隐藏缓冲区。
        <ctrl + ^> 切换到上次处于激活状态的缓冲区。
        当一个缓冲区由激活状态变为非激活状态的时候，vim会将其标记为隐藏缓冲区。

        按照顺序显示缓冲区，还可以通过缓冲区名称或者序号来指定显示某个缓冲区。
        例如使用:buffer 1 来显示编号为1的缓冲区。
        buffer {bufname} 来显示指定缓冲区，其中{bufname} 代表的是缓冲区的名称,
        例如:buffer init.lua

        不管使用:bnext 之类的命令切换还是使用:buffer 来切换缓冲区，
        都需要输入这么长的命令，显得既繁琐又低效，那
        么有没有什么办法来解决这个问题呢？答案是通过快捷键映射。
10.4 删除缓冲区
        如果要删除某个缓冲区可以使用
        :bdelete {bufname}或buffer {bufnum}。该命令支持前面几篇文章中提到的范围操作，
        即:nstart, nend bdelete 来删除编号nstart 到 nend 的所有缓冲区。
        缓冲区缓冲区编号是vim自己分配的，要通过编号删除得执行:ls命令，
        并且有时候删除了后续可能还要再次打开，
        再退一步说，如果暂时不想用它，
        vim也只显示后面打开的缓冲区，
        我们使用这个场景很少，除非有充足的理由，
        否则不会去删除它。

10.5 缓冲区列表参数
    在实际开发项目的时候，我们会打开很多文件，如果仅仅使用上述介绍的命令会发现在管理上有诸多不便。
    例如项目中有ui文件、有python代码、也有c代码、甚至还有java代码，
    我现在要找一个名为showUserName 的函数，而且我很清楚我要的ui中的内容，
    但是在python、c或者java中都有类似的函数名，采用全局搜索肯定都搜出来了，但是我只想在ui文件中搜索。
    这就涉及到项目文件的模块化。使用上述命令肯定无法满足模块化的要求。这个工作可以使用列表参数来完成。

    10.5.1 打开文件
        假设现在目录有3个python 文件，5个cpp 文件，还有2个txt 文件，
        我们按照文件类型进行分组打开，先打开cpp 文件.
        vim *.cpp
        使用 :args 显示参数列表
        它输出的内容如下：
        [a.cpp] b.cpp   c.cpp   d.cpp   e.cpp

    该列表记录了通过命令行另vim打开的所有文件缓冲区。
    其中使用[] 包裹起来的是当前处于激活状态也就是当前窗口显示的的缓冲。
    注意请不要被这个名字迷惑了，它并不是传递给vim的参数，而是作为参数传递给vim的文件的列表。
    也就是这条命令所打开的文件的列表。本质上仍然是一个缓冲区列表

    10.5.2 查看并添加参数列表
        除了使用:args查看参数列表，也可以在:args 命令后添加缓冲区名称，
        例如:args init.lua 这样就将一个新的文件纳入之前的缓冲区列表中进行管理。
        后续可以将需要统一管理的缓冲区使用该命令添加进来，
        除了使用详细的文件名一个个添加之外，vim也支持使用通配符来进行匹配。
        甚至也可以在后面添加shell命令，以shell命令的输出作为缓冲区列表的参数，添加到参数列表，
        它的形式为 :args `cmd`
        上述事例中，我们通过args 来将ls 输出的结果作为参数列表。
        再通过:ls 命令查看一下当前缓冲区列表，发现之前打开的仍然存在，
        只是我们将test.py 和 init.lua 这两个文件形成一组作为缓冲区的参数列表。

        :args 命令本身也支持使用通配符来将所有匹配的文件名设置为缓冲区列表参数，
        例如:args *.py 将当前目录中所有py文件加入，
        或者使用:args **/*.py 来将当前目录下所有子目录中的py文件加入。
        一般来说使用shell命令或者使用通配符的方式居多，但是也有直接使用文件名的情况出现。
        当我们指定好了一组缓冲区列表参数之后，
        可以使用:next 、 :prev 、first、last 在这组缓冲区列表中进行切换。

10.6 vim退出
    退出很简单，前面已经提过，在这里并不介绍使用何种命令来退出。
    而是介绍vim如何处理未同步到磁盘上的缓冲区的。
    我们随便打开多个文件，在任意一个或者多个缓冲区中执行o 或者其他能另其修改的命令。
    然后执行切换缓冲区的命令，例如:bnext 之类的，切换之后再次执行:ls
    我们发现在之前的基础之上，
    多了一个 + 它代表着这个缓冲区上的修改并未同步到磁盘文件中。
    此时如果执行:q 进行退出的话，会提示当前有缓冲区未同步到文件中，并且跳转到未同步的缓冲区。
    我们可以执行:w 来写入将缓冲区内容磁盘，
    也可以使用:q! 来忽略该缓冲区的修改，
    或者使用:edit!来强行的从磁盘读取内容并覆盖本次修改。
    这个时候vim将会切换到下一个未保存的缓冲区。
    如果嫌每次都这样比较麻烦，可以执行:qall! 忽略所有未修改的缓冲区并退出，
    或者使用:wall 来写入所有修改。
    退出可以试试 xa，相当于 wqa。很方便… x=wq

总结
    本文到此就结束了，最后再来总结一下该文中使用到的命令和快捷键：

    bnext: 切换到缓冲区列表中的下一个缓冲区
    bprev: 切换到缓冲区列表中的下一个缓冲区
    blast: 切换到缓冲区列表中的最后一个缓冲区
    bfirst: 切换到缓冲区列表中的第一个缓冲区
    <Ctrl+^>: 在上一个被激活的缓冲区和当前被激活的缓冲区之间进行轮换
    args: 显示当前缓冲区列表参数。后面也可以跟上文件名、shell命令和通配符，设置对应的缓冲区列表参数
    next: 切换到缓冲区列表参数中的下一个缓冲区
    prev: 切换到缓冲区列表参数中的上一个缓冲区
    last: 切换到缓冲区列表参数中的最后一个缓冲区
    first: 切换到缓冲区列表参数中的第一个缓冲区

    :badd               增加缓冲区
    :ls/:files/:buffers 列示缓冲区状态
    :buffer             编辑指定缓冲区
    :ball               编辑所有缓冲区
    :bnext              到下一缓冲区
    :bprevious          到前一缓冲区 
    :blast              到最后一个缓冲区
    :bfirst             到第一个缓冲区
    :bmodified          到修改过的缓冲区
    :bdelete            删除缓冲区
    :bunload            卸载缓冲区
    :next               切换到下一文件
    :wnext              保存后切换到下一文件
    :previous/:Next     切换到上一文件
    :wprevious/:wNext   保存后切换到上一文件
    :first/:rewind      切换到第一个文件
    :last               切换到最后一个文件
    :set autowrite      打开自动保存功能
    :set noautowrite    关闭自动保存功能
    :args               显示正在编辑的文件名
    :argument [N]       切换至第N号文件
    

==============================================================
                   10_多窗口
============================================================== 
vim多个窗口打开同一个文件的时候，他们享受同一个文件缓冲区，
在其中一个窗口编辑内容，其他窗口内容会跟着实时变化。

10_1 命令行命令：vim打开多个窗口
    //水平铺满，上下分割
        vim -o file1 file2 file3 ...
    //垂直铺满，左右分割
        vim -O file1 file2 file3 ...
    1.1 分屏启动vim
    vim -on/-On file1 file2 …
    小写的o表示水平分屏
    大写的O表示垂直分屏
    n是数字，表示分成几个屏

             关闭当前窗口

10_2 vim底行命令：当前窗口的基础上再打开新文件
    //在【左侧】打开文件(备注：不写文件名时，表示【再次打开当前文件】)
        :vsp new_file
        :vs<回车>
    //在【上方】打开文件(备注：不写文件名时，表示【再次打开当前文件】)
        :sp new_file
        :sp<回车>  

    :split             当前窗口一分为二，两个窗口显示相同内容。  
    :10split           新窗口的高度10行
    :split otherfile   新窗口中打开otherfile   
    :new               功能和split一样  
    :sp                split的缩写形式  
    ctrl+w+s           分割窗口的快捷方式
    :q        

    10_2.1 new 命令
        :new “新建一个未命名窗口
        :new name "新建一个名为name的窗口  
    10_2.2 横向分割窗口
　　　　 :split name "在当前位置打开name窗口 将原来文件向下移动
　　　　 :sp name "是split的缩写 与split功能相同
        如果省略名字，则新打开的窗口和打开它的窗口显示相同缓冲区的内容（同一个文件）。
    10_2.3 纵向分割窗口
　　　　 :vsplit name "在当前位置打开name文件 将原来文件向右移动
　　　　 :vs name "是vsplit的缩写 与vsplit功能相同
        如果省略名字，则新打开的窗口和打开它的窗口显示相同缓冲区的内容（同一个文件）。
    10_2.4 快捷键分屏
        Ctrl+W s 水平分割当前打开的文件，相当于执行split省略文件名的命令
        Ctrl+W v 垂直分割当前打开的文件，相当于执行vsplit省略文件名的命令
10_3 切换窗口
    <ctrl+w> h/j/k/l   光标切换到：【左、下、上、右】的窗口（
    附：如果把hjkl换成大写，则会直接将当前光标窗口进行移动）

    <ctrl+w> t         切换到：左上角
    <ctrl+w> b         切换到：右下角
    <ctrl+w> p         切换到：上次一光标所在窗口

    <ctrl+w> w         依次轮询切换窗口
    num <ctrl+w> w     直接定位到当前screen第num个窗口（左上角是第1个，从左往右，从上往下数）

    3.1 鼠标
        还有一种可以使用鼠标左键点击直接切换窗口的方法，
        底行模式输入命令下面命令就可以直接鼠标左键点击切换窗口了：
            :set mouse=a
        但是这样就没法用鼠标左键选中文本复制了，取消鼠标的方法为底行模式命令：
            :set mouse=

10_4 调整窗口尺寸
    <ctrl+w> =        当前屏幕所有窗口【等宽且等高】
    <ctrl+w> |        当前窗口【宽度】调到最大（竖线:shift \）
    <ctrl+w> _        当前窗口【高度】调到最大（下划线：shift 减号）

    //不加num默认操作一个长度单位
    num <ctrl+w> +    将当前窗口【增高num行】
    num <ctrl+w> -    将当前窗口【减少num行】
    num <ctrl+w> >    将当前窗口【变宽num行】
    num <ctrl+w> <    将当前窗口【变窄num行】

    <C+w>=			# 所有窗口等宽、登高，默认
    <C+w>|			# 最大化当前窗口的宽度
    # 调整高度
    N<C+w>+			# 将当前窗口高度增加N行，N默认为1
    N<C+w>-			# 将当前窗口高度减少N行，N默认为1
    N<C+w>_			# 将当前窗口高度设置为N行，N默认最大化

    # 调整宽度
    N<C+w> <		# 将当前窗口宽度减少N行，N默认为1
    N<C+w> >		# 将当前窗口宽度增加N行，N默认为1
    N<C+w> |		# 将当前窗口宽度设置为N行，N默认最大化


    --------------------------------------------------
    按键备注：
    # 减号 -
    # 等号 =
    # 加号 【shift =】
    # 下划线：【shift 减号】

10_5 关闭窗口
    5.1 底行模式命令：
        //a参数表示所有窗口，如：
        :qa 关闭所有窗口
        //其他参数和单窗口操作一样，如w保存，!强制退出，如：wqa/qa!/wqa!等
    #关闭当前窗口
        :close
    #保留当前窗口，关闭其他窗口
        :only
==============================================================
                    11 标签页操作
==============================================================  

11.1 打开标签页
    可以使用命令:tabedit {filename} 打开一个新的标签页，
    如果不加文件名则打开一个空的标签页。
    我们也可以使用tabnew 命令，参数与效果完全相同。
    如果当前标签页中包括多个窗口，
    那么可以使用<Ctrl+w>T 将当前缓冲区移动到新的标签页中。

11.2 关闭标签
    可以使用tabc[lose] 或者使用tabo[nly] 来关闭标签页，
    前者是关闭当前标签页，后者是关闭所有，只保留当前激活的标签页。
    
11.3 切换标签页
    在普通模式下使用gt 切换到下一个标签页，
    使用gT 切换到上一个标签页，
    也可以在命令模式中使用:tabn[ext] 和 tabp[revious] 来达到同样的效果。
    另外tabnext 和gt 前面都是支持添加数字编号的。
    这样我们可以方便的跳转到第几个标签页，这个编号是从1开始的。
    
最后总结一下提到的一些命令：
    :tabedit {filename}  新建标签页，并在标签页中打开对应文件
    :tabnew与:tabedit 完全相同
    <Ctrl+w>T 如果当前标签中有多个子窗口，它会将当前活动子窗口放到新的标签页中
    :tabc[lose]关闭当前标签页
    :tabo[nly] 关闭除当前激活标签页的所有
    gt 或 :tabn[ext] 切换到下一个标签页
    gT 或 :tabp[revious]切换到上一个标签页
    :tabmove {n} 移动当前标签页
    
==============================================================
                    12 打开及保存文件
==============================================================    
12.1 开始前的准备
    vim自己也有一个工作目录的概念，可以通过:pwd 来查看当前vim的工作目录是哪个，
    一般来说我们是从shell中的哪一个目录中进入的vim，那么vim的工作目录就是哪个。
12.2 edit命令
    :edit {filename} (或者简写为 :e ) 。
    如果filename采用绝对路径，那么打开的就是绝对路径所对应的文件，
    如果是相对路径，那么就可以打开相对与vim工作目录的文件。

    vim 在命令行中提供了一个% 作为活动缓冲区的完整路径。
    可以通过 :edit %<Tab> 来自动显示整个路径，
    然后通过<C-w> 来删除单词，直到删除到当前目录

    以通过 在%的后面加上:h 来自动去掉文件名，即输入:edit %:h<Tab> 来自动出现对应的目录。
    这个功能还是挺有用的，但是需要输入这么多内容，为了简化它你肯定也想到了，要给它配置快捷键。

12.3 find命令
    操作系统中，有一个PATH 环境变量，输入命令的时候，
    他会在PATH 所指定的目录中查找对应命令。vim中也有类似的概念。

    vim中可以使用:find，根据输入的文件名打开文件。
    但是使用:find 的前提是配置path 变量。
    它们合作完成打开文件的操作，与环境变量的用法类似。

    可以输入:set path+=./** 将当前工作目录以及它下面的所有子目录。
    然后可以直接输入:xx 打开这个文件了。
    若有同名文件，打开当前文件所在目录附近的同名文件，然后可以用tab选择。

12.4 vim自带的目录管理工具
    在一般的ide中，左侧或者右侧会以树的形式显示项目中的目录。
    vim中也有这样的功能。它是vim提供的一个名为netrw 插件。

    12.4.1 打开目录显示
        我们打开一个目录就可以看到，它在窗口中显示该目录中的文件结构。
        它与普通的缓冲区窗口一样，可以通过motion 操作来移动光标。
        也支持命令行模式，但是这个缓冲区是不可修改的，也无法保存。
        在该窗口中，随意选择一行按下回车，如果选择的是一个文件，
        那么它会打开该文件，如果是目录那么窗口中则会进入该目录并显示目录内容。

        我们可以像打开一个普通的文本文件那样打开一个目录，
        二者的区别仅仅在于显示的内容不同，某些行为不同而已。
        如果当前已经打开了一个文件，我想再继续显示这个目录呢？
        既然可以以打开普通文件的方式打开新的目录，
        那么我使用:edit 命令，在后面加入目录路径就可以了。
        vim也提供了:Explore 专门用来显示目录结构。
        它可以简写为:E 后面不加任何东西可以打开当前文件所在目录，
        也可以加上路径打开指定目录。

        如果我们想要像普通编辑器那样将目录结构放到左边怎么办呢？
        套用打开文件的方式，各位肯定能想到使用:vsplit 加上目录名。
        vim也提供了一组命令:Sexplore和:Vexplore 分别在水平和竖直方向打开目录。

        vim自带的这个目录管理工具最大的问题是我通过回车键从里面选择一个之后，
        会在当前窗口打开一个新的缓冲区，并且把目录树给覆盖了，
        这个时候我们可以快速按下<Ctrl + Shift>^ 来在新打开的缓冲区和目录树之间切换。

        除了浏览目录结构以外，也可以利用该插件进行文件和目录的创建、删除、修改、重命名等操作，
        例如，使用% 来创建文件, 
        d 来创建目录，
        R 重命名或者移动目录和文件，
        使用 D 来删除一个目录或者文件

12.5 写入文件的一些小技巧   
    12.5.1 写入不存在的目录中
        我们在原项目的基础之上打开一个新的有不存在目录的文件，
        例如:e random/111/test.txt。
        成功的进入了vim的编辑界面，我们也可以进行编辑，但是一旦执行写命令的时候，
        发现vim会提示目录不存在。它保存文件需要将文件保存到一个已经存在的目录中。
        可以退出vim，然后使用mkdir 来新建目录。
        这个是下下策，之前输入的内容全丢失了，再重新来一遍实在是令人恼火，不瞒各位，我之前就是这么干的，所以我养成了，新打开一个文件就立马执行:w 的习惯。
        还记得之前讲过怎么在vim中执行shell命令吗，不想退出vim，又想在保存前创建目录，可以使用这招, :!mkdir -p random/111, 然后再执行写入。
        或者可以灵活的使用在前面介绍的:%h 来快速补全相对路径。

    12.5.2 强制以root用户写入文件
        有时候我们使用vim打开了系统文件，例如打开了/etc/hosts 文件，
        但是保存的时候意识到忘了加sudo 了，导致无法写入，
        我以前的办法是先退出，然后再用root权限打开，
        这样就导致之前输入的内容全都丢失了，幸亏我养成了前面说的那个习惯，
        打开文件之后的第一步就是执行:w,
        在学习了vim的命令模式之后，估计各位小伙伴已经有思路来解决这个问题了。

        以当前文件内容作为命令输入，配合shell命令，完成。
        我们知道可以使用tee 来将输入内容写入文件中。
        那么我们的命令可以是 :w !sudo tee % > /dev/null, 
        我们使用:w 来指定当前缓冲区的内容作为shell命令的输入。
        然后配合tee 来将内容写入到% 也就是当前文件。

        写入文件之后vim会检测到该文件已经被外部的程序修改了，本例中它被 tee 命令修改了，
        因此这个时候vim会提示我们文件已经被外部程序修改，需要重新载入文件还是使用当前缓冲区的内容。
        因为这里我们是将缓冲区内容直接覆盖到文件里面，二者的内容是一样的，使用哪个都行。

    12.5.3 :w !sudo tee %命令
        当你在Vim中执行:w !sudo tee %命令时，实际上发生了以下几个步骤：
        :w命令：这是Vim的写入（write）命令，它通常用于将当前缓冲区的内容保存到文件。
        但是，当w命令后面跟着一个!时，Vim会将当前缓冲区的内容写入到一个外部命令的标准输入，而不是写入到文件。这就是为什么这个命令可以在没有写入权限的情况下保存文件。

        !sudo tee %：这是一个外部命令，Vim会将当前缓冲区的内容写入到这个命令的标准输入。
        这个命令由两部分组成：

            sudo：这是一个Unix命令，它允许用户以超级用户（root）的权限运行命令。
            在这个例子中，它使得tee命令可以以root的权限运行，从而可以写入到没有写入权限的文件。

            tee %：tee是一个Unix命令，它从标准输入读取数据，并将数据写入到一个或多个文件中。
            在这个例子中，%是一个Vim的特殊符号，代表当前编辑的文件名。
            所以，tee %命令会将从Vim传来的数据写入到当前编辑的文件中。

        总的来说，:w !sudo tee %命令的工作原理是：
        Vim将当前缓冲区的内容写入到sudo tee %命令的标准输入，
        sudo tee %命令以root的权限将这些数据写入到当前编辑的文件中，
        从而实现了在没有写入权限的情况下保存文件。
    12.5.4 tee、vi/vim命令
        tee：多重定向
            语法：
                tee [OPTION] ... [FILE] ...

            参数：
                将标准输入复制到每个FILE，也复制到标准输出。

                -a，--append
                        追加到给定的文件，不要覆盖

                -i，--ignore-interrupts
                        忽略中断信号

                --help显示此帮助并退出

                --version
                        输出版本信息并退出

                如果FILE是-，则再次复制到标准输出。

            实例1:tee不加任何参数的应用
           ~/tmp$ ls
                1.txt  2.txt
            ~/tmp$ ls | tee ls.txt
                1.txt
                2.txt
                ls.txt
            ~/tmp$ ls
                1.txt  2.txt  ls.txt
            ~/tmp$ cat ls.txt
                1.txt
                2.txt
                ls.txt
            实例2:tee加参数-a追加
                ls | tee ls.txt -a

            实例3：tee用来显示屏幕并且保存在文件中
            echo "123" | tee tee.txt 显示到屏幕并且存在文件中

            实例4:(|) 管道符用来覆盖上一文件内容
                echo "789" | tee tee.txt  覆盖掉原来的

            实例5：-a用来追加文件内容
                echo "111" | tee tee.txt -a 追加



==============================================================
                    13 motion 进阶
==============================================================    
13.1 vim屏幕行与实际行
    vim中有一个wrap 设置，表示一行文本超过多少行就会自动折行，
    这样就不会出现在一个屏幕上显示不全的问题了。

    在启用自动折行的设置后，如果一行文本字符数超过设置的值会自动折行。
    在屏幕上显示为多行。

    当我们开启了显示行号的设置之后很容易区分。
    实际行在vim中只显示一个行号，而在屏幕上会显示多行。

    我们知道行间移动使用的是j、k, 他们是在实际行之间移动，
    如果想要在屏幕行间移动，可以使用 gj、gk。
    一般针对行相关的操作，只需要在前面加上g 就可以改成在屏幕行之间的操作。
    例如g0 是移动光标到屏幕行行首。
    g$ 移动到屏幕行行尾。
    他们与普通的行移动motion 用法类似，
    即可以配合数字表示重复，
    也可以配合operator 来执行相应的操作。

13.2 单词与字串
    在vim中一个单词由字母、数字、下划线或者其他非空白字符组成，单词间以空白字符分割。
    而字串是由非空白字符序列组成。这个感觉可能很抽象，但是多多练习和尝试应该就很容易明白了。
    字串间的移动使用大写的W， B。下面来看一个例子:
    e.g. there's a nvim config file in "~/.config/nvim/init.lua"

总结如下：
    1. 区别单词应该以字母、数字、其他非空白字符进行分类
    2. 字串仅仅以空白字符为区分
    3. 同一类型的字符序列组成的部分作为一个单词。

    例如上述句子由字母、空白字符和其他非空白字符（. ' ~ /）组成, 
    e.g. 后面是一个空白字符，因此它被划分为一个字串，
    而它自身经历了字母、非空字符、字母、非空字符的序列，
    所以vim将他们划分为了4个单词。
    如果这样比较麻烦，那就简单的记住：字串比单词要长，
    不需要细粒度的移动，可以用字串间移动。


==============================================================
                    14 快速跳转
============================================================== 
14.1 利用标签，快速跳转
    vim中提供了标签的方式进行跳转，事先可以在对应位置设置标签，后面通过标签访问该标签所在位置.
    可以使用m{a-z} 来在任意位置设置标记，而后使用`{a-z}来回到对应标记位置。
    该命令可以回到之前设置标签时光标所在行和列。

    vim可以支持从a到z的26个位置标记，一般来说我们用不到这么多，
    即使你能全部用到，可能早就忘了前面标记的在哪个位置了。
    这种方式有一个最大的问题就是在标记之后从显示上无法知道我们的标记位于何处。

    除了由用户主动使用m 来设置位置标记以外，vim还会自动为我们设置标记，
    例如上次修改、上次跳转、上次高亮等等。

    下表列举出了，如何回到这些vim自动标记所在位置

    位置标记        	    含义
        ``	        当前文件中上次跳转动作之前所处的位置
        `.	        上次修改的地方
        `^	        上次进入插入模式的位置
        `[	        上次修改或者复制的起始位置
        `]	        上次修改或者复制的结尾位置
        `<	        上次高亮选区的起始位置
        `>	        上次高亮选区的结尾位置
        ctrl+]      跳转到链接      
        ctrl+t      从链接返回
        可以按 ' 来跳，感觉比 ` 好按些
14.2 在匹配的括号间进行跳转
    可以使用 % 在一组括号中使用，可以跳转到下一个匹配的()、[]、{}。
    例如下列操作，我们可以配合operator 来使用，删除括号中的内容。例如下面的代码：
    var foo = 
    {     
        "obj":{
            "test": "1",
            "arr": [1, 2, 3]
         }
    }
    可以使用将光标移动到对应的位置，然后使用d% 就可以删除对应的内容了。
    当然也可以使用文本对象来进行。

14.3 跳转列表
    浏览器中会记录浏览历史，并且提供了去到上一页和下一页的功能。
    vim中也提供了类似的功能，vim会记录我们每一次的跳转，
    可以通过相关命令来跳转到上一次跳转和下一次跳转的位置。

    我们先介绍什么是跳转。跳转似乎很容易理解，似乎光标每次的移动都算是一次跳转。
    但是vim中的跳转并不是这样的。我们可以先这样理解，motion 允许我们在一个文件中进行移动。
    而跳转则是不同文件间的移动。就像在浏览器中从一个页面打开另一个页面。
    为了类比浏览器的操作，你也可以把每次跳转记录理解成历史访问文件的记录。
    可以使用:jumps 来查看跳转记录。

    从上图中可以看到这样几个现象：
    跳转列表中记录了所在文件以及上次光标所在的行和列。
    最后几行由于我们处在当前文件中，所以没有列出文件名称来，而是直接给出光标所在行的文本内容，
    由于我这里打开文件之后立即查看了跳转列表，光标处于第0行这个虚拟行，所以会显示空白内容。
    它记录了光标所在的行列，所以后面我们在恢复的时候可以直接定位到具体位置。
    与浏览器类似，之前打开vim的时候访问文件的记录也在里面，它并没有随着vim的关闭而被清除。
    任何能改变当前窗口中活动文件的命令都可以作为跳转命令，像find、edit 之类的。

    了解了跳转列表之后，我们现在来访问一下这个跳转列表。
    可以使用<Ctrl + i> 来访问前一个跳转，<Ctrl + o> 来访问后一个跳转。
    在nvim-config 中随意打开一个文件，然后使用edit 打开另一个，
    接着就可以使用<Ctrl + i> 和 <Ctrl + o> 在两个文件中切换了。
    返回上一个文件可以按 <c-6> 或者 :e# 。
    这玩意儿比 <c-o> 跳的跨度大，还是很方便的

    我们再来联想一下浏览器中的历史记录，我们发现有时候访问同一个页面的不同位置可能会产生多条历史记录。
    例如访问同一页面的不同锚点。
    那么我们之前说的将跳转理解为历史文件访问记录可能就不对了，同一个文件也可以产生多个跳转记录。 
    例如gg(G)、%、\{a-z}等等。而h j k l w f之类的就不作为一次跳转。
    用一句话来总结就是大范围的光标移动才会被作为一次跳转。
    什么会被作为大范围的移动呢？我个人的理解是一次移动有能力移动至少半屏，
    而像50j 之类的虽然也可以移动50行，也达到半屏以上，但是前面加数字表示的是重复，
    它是重复了多次，并不算一次移动。

    我们使用split 或者 vsplit 再打开一个新的窗口，然后在两个窗口中分别使用:jumps 发现二者并不相同。
    vim可以维护多套跳转列表，每个窗口都有自己的一套独立的跳转列表。
    这个与浏览器中的也类似，新窗口并不能进行前进和后退操作，
    而且这两个操作也只能跳转到由这个窗口打开的网页上。

14.4 改变列表
    我们不管在文件的哪个位置，使用u撤销修改的时候光标总能跳转到对应修改的位置，
    或者使用`. 能回到上次修改的位置。

    :changes :
        im在会话期间会维护一张表，表里记录了每个缓冲区的每一次修改。这个就是所谓的改变列表。可以使用   changes 来查看这个列表

    g; 和 g,
        这个列表与跳转列表类似，都标记了行号与列号。
        我们可以通过g; 和 g, 来访问下一个和上一个记录。
        你可以拿;和, 来类比记忆。这两个操作符是配合f来使用的。
        ; 移动到下一个匹配位置，, 移动到上一个匹配位置。

    gi,`.,`.
        我们可以使用`.来跳转到上一次修改的位置，而 `^则更具体一点。
        它代表的是上一次退出插入模式光标所在位置。
        如果我们在做出修改并且退出插入模式之后，移动光标查看了下其他类似代码的实现，
        然后想快速回到之前编辑的位置继续编辑，可以使用 `^将光标移动到对应位置，
        然后使用i进入插入模式，当然也可以使用gi 一步到位，直接从上次编辑位置进入插入模式。

    需要注意的是，vim会为每一个打开的窗口维护一个跳转列表，但是更新列表只有一个，
    而且跳转列表并不会随着vim的退 出而消失，但是改变列表则会随着vim的退出而被清空。

14.5 跳转到光标下的文件
    :set path+=./**
        我们将当前项目所在的所有路径加入到path中之后(即在项目根目录中执行:set path+=./**)
        :set 以将光标移动到对应表示相对路径的代码上，执行gf 即可跳转到对应文件。

    :set suffixesadd+=.java
        在上面的例子中，我们只写了settings 这样的文件，它是如何知道要打开 settings.lua 文件的呢，
        或者说如果有类似的settings.h 或者 settings.js 在同一个位置的话，它该打开哪一个呢？
        im 中有一个suffixesadd 变量，它保存的当前缓冲区中执行gf操作时，可以使用的扩展。我们可以像设置path  一样，例如:set suffixesadd+=.java 来允许打开java文件。
        使用gf 也是一个跳转，也会被记录到跳转列表中，后续我们可以使用之前介绍的
        <Ctrl + o> 和 <Ctrl + i> 来  回的在两个文件中切换。

14.6 使用全局书签在文件间跳转
    之前介绍过在文件中可以使用标记，在文件不同位置进行跳转。
    那个时候说到使用小写字母设置标记，小伙伴们可能会产生疑惑，那大些字母去哪了呢，
    为什么只能使用小写字母，而大写字母被空着呢？
    文章写到这里了，我可以告诉大家，大写字母被用到了全局书签里面。

    全局书签与之前介绍的标记使用方式一模一样，只是一个使用大写字母，一个使用小写字母。
    例如在上面一个例子中，我们在跳转到settings.lua 之前先使用mI,
    在init.lua中一个标签，在跳转之后使用 `I 快速跳转回来。

    Marks 可以按 ' 来跳，感觉比 ` 好按些。
    返回上一个文件可以按 <c-6> 或者 :e# 。
    这玩意儿比 <c-o> 跳的跨度大，还是很方便的

==============================================================
                    15 寄存器
============================================================== 

        

vim共有9类寄存器：
    无名（unnamed）寄存器：​​""​​，缓存最后一次操作内容；
    数字（numbered）寄存器：​​"0 - "9​​，缓存最近操作内容，复制与删除有别；
    行内删除（small delete）寄存器：​​"-​​，缓存行内删除内容；
    具名（named）寄存器：​​"a - "z​​或​​"A - "Z​​，指定时可用；
    只读(read-only)寄存器:​":, "., "%, "#​​,分别缓存最近命令、最近插入文本、
                            当前文件名、当前交替文件名；
    表达式（expression）寄存器：​​"=​​，只读，用于执行表达式命令；
    选择及拖拽（selection and drop）寄存器：​​"*, "+, "~​​，存取GUI选择文本，可用于与外部应用交互，
                                            使用前提为系统剪切板（clipboard）可用；
    黑洞（black hole）寄存器：​​"_​​，不缓存操作内容（干净删除）；
    模式寄存器（last search pattern）：​​"/​​，缓存最近的搜索模式。



15.1 无名寄存器
    当使用y命令复制文本，或使用d、c、s、x等命令删除文本时，文本将自动被放入""未命名寄存器。
    即使你在复制或删除文本时，已经指定了寄存器（例如使用"xdd命令），这些文本也将同时被放入"x和""寄存器。

    例如

        print("hello world") 
        print("")
        为

        print("") 
        print("hello world")

    就可以在第一行通过di"，将被删除的内容存储到无名寄存器中，
    然后在第二行对应位置执行 p (或者P) 命令取出无名寄存器中的内容。

15.2 有名寄存器
    对应无名寄存器的是有名寄存器，无名寄存器使用方便，但连续两次执行删除或者复制操作，
    前一次内容会被后一次覆盖。使用有名寄存器可解决这个问题。
    vim中提供了由a到z的有名寄存器，可以在使用operator 的操作前面指定需要使用的寄存器，
    引用一个寄存器可以使用 " + 寄存器名的格式。
    这个时候我们之前的公式就又可以扩展了
        " + regester + operator + motion
    例如在执行删除的时候 
        add 将一行删除的内容放到a寄存器中，再次执行
        bdd将内容放到b寄存器中，执行粘贴的时候，可以使用
        "ap和 "bp来分别使用a和b寄存器的内容。
    无名寄存器有一个专用的符号，使用 "来表示。
    也就是说dd 命令其实等效为 ""dd。但是为了偷懒和方便，还是少输几个字符的好。

15.3 复制寄存器
    前面说到使用 dd 之类的命令会将被删除的内容放到无名的寄存器中，
    它的行为有点像普通编辑器中的剪切，那它是不是剪切呢，那么多教程都把它叫做删除，是不是有问题呢。
    它确实是删除指令，教程说的也没错，vim中有专门存储复制内容的寄存器。
    普通的删除命令会把被删除的内容保存到无名寄存器中，但是这些内容不会被保存到复制寄存器中。
    复制寄存器使用 0来表示。即我们可以使用 
    "0p来将复制寄存器的内容取出。也可以通过命令 
    :reg 0来查看这个寄存器的内容。

    在一个例子中，我们先在第一行执行 yy 操作进行复制，
    这个时候数据会被同时保存到无名寄存器和复制寄存器。
    然后在第二行执行 dd 删除，这个时候第二行的数据会被保存到无名寄存器，
    之前保存的第一行的数据就被删除了，但是不会被保存到复制寄存器，
    第一行的数据仍然存储在赋值寄存器。
    接着立即执行p 它会从无名寄存器中中取出我们之前删除的第二行的数据。接着再执行
    "0p 会从复制寄存器中取数据，这个时候取出的仍然是第一行的数据。

15.4 黑洞寄存器
    前面说到 dd会将被删除内容放入到无名寄存器中，
    如果这段内容我确实不想要了，也不想它占用寄存器，有没有什么办法彻底删除呢，
    答案是使用黑洞寄存器，顾名思义，放入该寄存器中的内容都被吸走丢失了，无法使用了。
    黑洞寄存器使用 _作为标识符，执行删除指令的时候可以使用 "_dd这样就再也访问不到之前删除的内容了。

    在上面的例子中，我们先执行普通的dd 命令，它会将删除内容放入到无名寄存器中，第二次执行的是 
    "_dd ，它会将内容放到黑洞寄存器中直接丢弃，后面执行p 的时候只会粘贴第一次删除的内容。
    有小伙伴可能会说，这个跟我使用其他有名寄存器效果是一样的。
    看不出什么区别，那么我们可以试试使用 :reg 命令来查看有名寄存器和黑洞寄存器的值，
    我们发现黑洞寄存器的值永远为空，而有名寄存器此时多了一条记录。

15.5  系统剪切板
    之前我们在vim中复制粘贴的内容，只能在vim中使用。
    同样的系统中复制粘贴的内容只能在系统其它程序中使用，无法直接粘贴到vim中。
    我们可以在vim中使用系统剪切板。vim可以使用+来访问系统剪切板。例如使用 
    "+yy将内容复制到系统剪切板中，供其他程序使用。

    但是在有好的shell工具的加持下，我更喜欢用<Ctrl+v>这样的方式直接粘贴一大段文字到vim中。
    或者配合vim的可视模式，直接使用shell中的快捷键从vim中粘贴选中的内容到系统剪切板

15.6 表达式寄存器
    前面介绍的几种寄存器都是被动的存储静态的内容，只有存储功能。
    表达式寄存器则可以接受一段vim脚本并执行它并输出结果。表达式寄存器使用 
    =来表示。
    例如在插入模式中可以使用 
    <Ctrl+r>=6*6 来进行数学计算并输出。

示例1：复制粘贴的使用

    假设我们要将如下代码
        print("hello world") 
        print("hello vim")

    修改为
        print("hello world")
        print("hello world")
        
    可以在第一行使用 
    yi"来复制引号内的内容，但是如果在第二行先使用 
    di"再使用p进行粘贴的话会发现粘贴的仍然是hello vim
    这是因为后面使用d操作的时候，已经将原来的给覆盖掉了。
    现在我们来解决这个问题。

    第一种解法：
        y指令可以额外产生一个动作，它会将内容放入到复制寄存器中，那么在执行了ci"之后使用 
        “0p来使用复制寄存器中的内容.
    第二种解法：
        可以手动指定di"删除的内容放入到黑洞寄存器中，即执行”_di"这样就不会产生覆盖问题。
    解法三：
        由于我们需要先删除之前的内容再复制，为了快速删除，所以会发生覆盖问题，
        我们只要不执行删除操作就不会覆盖了，为了一次性完成粘贴替换的操作，可以使用选择模式，
        之前介绍选择模式的时候说过，在选择模式下operator 会将选中部分作为操作区域。
        可以使用 vi" 来选中引号内容，然后直接使用 p 完成复制

示例2：插入模式中使用寄存器
    之前已经在介绍表达式寄存器的时候已经介绍了如何在插入模式中使用寄存器，
    可以使用 <Ctrl + r> + register 例如上面的例子可以使用 
    <Ctrl + r>0来将复制寄存器中的内容写入到光标所在位置。

示例3 ： 处理粘贴混乱的问题
    有的时候在粘贴代码的时候发现代码的格式可能会乱，这个时候可以设置 
    :set paste 选项，设置之后复制粘贴将不再出现这个问题，但是它会使我们在其他模式下设置的快捷键失效，在粘贴完了之后可以使用 
    :set nopaste 取消该设置。由于我使用的neovim中没有发现这个问题，就不演示了，各位使用vim的小伙伴可以自行测试。

    当然处理该问题的另一种方式是使用之前介绍的在vim中使用剪切板的方法，也就是使用 
    "+p这样的形式。

当然处理该问题的另一种方式是使用之前介绍的在vim中使用剪切板的方法，也就是使用 "+p这样的形式。
==============================================================
                     15_ 寄存器
============================================================== 
15_1 指定寄存器
    在复制或删除文本时，可以使用"register命令将文本放入指定的寄存器中。
    例如以下命令，将复制的文本放到寄存器a中，同时文本也会被放入未命名寄存器中。
        "ayy
    如果再使用相应的大写字母来指定寄存器，那么会将当前行内容追加到寄存器a中，
    这时该寄存器中就有了两行文本。
        "Ayy

    Vim操作的是寄存器而不是系统剪贴来存储缓存。

    普通模式下，从某个特定的寄存器中读取文本的通用语法是
        "x，其中x是寄存器的标志。
    默认使用修改c或d删除或y复制的内容都放到了"匿名寄存器"。
    比如用x删除一个字符放到无名寄存器，然后p粘贴，可以调换字符。

    插入模式下，取出某个寄存器里面的内容放入到当前缓冲区中的方法为
        ctrl-r x，其中x是寄存器的标志。

15_2 查看寄存器
    使用registers name命令，可以查看特定寄存器中的内容：
        :registers a
    如果想要查看所有寄存中的内容，可以使用以下命令：
        :registers
15_3 寄存器类别
    寄存器可以分为以下十种类型：

        类别              符号                描述                                       
        未命名寄存器            "           上一次复制或删除的文本      
        数字寄存器              0-9         文本复制和删除历史                   
        行内删除寄存器          -           删除少于一行的文本                                      
        命名寄存器              a-z,A-Z     存放文本                        
        只读寄存器1             %           当前文件名       
        只读寄存器2             .           最近插入的文本
        只读寄存器3             :           最近执行的命令行
        轮换缓冲区寄存器        #           交替文件的名字            
        表达式寄存器            =           返回表达式结果        
        选择和拖拽寄存器1       *           系统剪切板             
        选择和拖拽寄存器2       +           系统剪切板 (X11)
        选择和拖拽寄存器3       ~           拖拽的文本
        黑洞寄存器              _           彻底删除的文本         
        搜索模式寄存器          /           最近搜索模式

    轮换缓冲区寄存器 "# 也可以认为是只读寄存器

15_3.1 未命名寄存器（The Unnamed Register） 
    当使用y命令复制文本，或使用d、c、s、x等命令删除文本时，文本将自动被放入""未命名寄存器。
    即使你在复制或删除文本时，已经指定了寄存器（例如使用"xdd命令），这些文本也将同时被放入"x和""寄存器。

15_3.2 数字寄存器（The Numbered Registers） 
    "0包含最近复制的文本；"1包含了最近删除或者修改的文本。
    区别在于："0不断被复制的文本所覆盖；
    而在删除文本时，如果指定了寄存器或者文本小于一行，那么"1将不会被覆盖。
    数字寄存器1-9可以看作是删除历史， 你可以从中找到早先删除的文本。
    比如使用了三次dd命令，那么这三行文本被分别存放在寄存器1,2,3中，
    可以通过命令"1P,"2P,"3P将这些文本再粘贴回来。

15_3.3 行内删除寄存器（The Small Delete Register） 
    当删除文本少于一行时，内容将被放入"-寄存器，除非指定了其它寄存器。

15_3.4 命名寄存器（The Named Registers） 
    当文本被放入以小写字母命名的寄存器（例如"a）时，该寄存器原有的内容将被覆盖；
    而使用以大写字母命名的寄存器（例如"A）时，将会把文本追加到原有内容之后。

15_3.5 只读寄存器（The Read-Only Registers） 
    你只能从只读寄存器中粘贴内容，而不能放入文本。
        "%包含当前文件名；
        ".包含最近插入的文本；
        ":包含最近执行的命令行。

15_3.6 轮换文件寄存器（The Read-Only Registers） 
    "#包含当前窗口轮换文件的名字。它影响CTRL-^的工作方式。该寄存器的值可以更改？

15_3.7 表达式寄存器（The Expression Register） 
    可以进行表达式计算并返回结果。
    在常规模式下，输入"=，就会在Vim底部显示以“=”开始的提示行，
    可以在其中输入表达式并按回车键确认。
    随后使用命令p，可以将表达式的结果粘贴到文本中。
    例如在=提示符后输入“5*5”并按回车，然后输入命令p，
    就可以将计算结果“25”插入文本中了。

    在插入模式下，点击Ctrl-R=快捷键，
    也可以进入=提示行，输入表达式然后点击回车键，将计算结果插入到当前光标处。
    也就是说，不用离开插入模式，也无需额外执行粘贴命令，即可以完成表达式计算。
    在表达式寄存器中，不仅可以使用通常的算术运算符，还可以使用Vim特定的函数和运算符。
    例如通过表达式寄存器来得到环境变量的值（例如"=$HOME）。
    如果没有输入任何表达式而直接按回车键，那么Vim将执行最近使用过的表达式。

15_3.8 选择和拖拽寄存器（The Selection and Drop Registers） 
    有3个寄存器用于保存选中的文本：
    在Mac和Windows下，"*和"+，都用于访问系统剪切板；
    在Linux下，"+用于访问系统剪切板，而"*包含选中的文本。
    使用"+y命令，可以将当前选中的文文本复制到系统剪切板中。
    而"+p命令，则可以粘贴系统剪切板中的内容。
    通过剪切板寄存器，能够在不同的Vim编辑器或者是其他应用程序之间，进行文本交换。
    "~包含上次从其它应用程序拖拽到Gvim中的文本。

15_3.9 黑洞寄存器（The Black Hole Register） 
    任何放入"_中的文本都将不复存在。
    如果想要永久删除某些文本而不将其放入任何寄存器，那么可以使用黑洞寄存器。
    例如：命令dd将删除一行文本并将其放入寄存器"1中；
    而命令"_dd则将该行文本放入黑洞寄存器中，这些文本也就永久消失了，而寄存器"1中的文本会保持不变。

15_3.10 搜索模式寄存器（Search Pattern Register） 
    当通过/命令进行搜索时，所使用的模式将被自动放入"/寄存器。        

15_3.11 粘贴寄存器
    命令:put会将寄存中的内容粘贴到指定的文本行后面。
    使用以下命令，可以将寄存器中的内容粘贴到第五行的后面:
        :5put a

    如果要将文本放在这一行的前面，可以用以下命令：
        :5put! a

    你也可以使用p命令，将x寄存中的文本粘贴到光标之后：
        "xp

    而P命令，则将x寄存中的文本粘贴到光标之前：
     "xP

    如果直接使用p或P命令，而没有指明特定寄存器，那么将粘贴未命名寄存器中的内容。
    使用以下命令，可以粘贴上次插入的文本，方便你录入重复的内容：
        ".P
    如果要粘贴系统剪切板中的内容，
    在Insert mode下可以利用快捷键Shift+Ins，
    而在Normal mode下，可以使用以下命令：
        "*p
    在插入模式下，点击CTRL-R然后输入寄存器的标识符，可以粘贴相应寄存器中的内容到当前位置。例如：

    CTRL-R: 将粘贴最近执行的命令；

    CTRL-R/ 将粘贴最近使用的搜索模式；

    CTRL-R0 将粘贴"0寄存器的内容；
 
    CTRL-Ra 将粘贴"a寄存器的内容。

    使用以下命令，可以查看相关帮助信息：
    :help i_CTRL-R 
15_4. 关于宏录制的小技巧 
    我们在正常模式下录制宏的时候，使用的就是上面介绍的寄存器。
    除了黑洞寄存器和只读寄存器不能用于录制宏以外，其它寄存器都能够用于录制宏。 
    当我们录制一串较长的命令时，可能因为某个地方出了错，导致录制失败，需要重新开始。
    不过，既然录制的宏存放于这些寄存器中，那么我们就能够像读取普通文本一样读取它们。 
    例如，我使用寄存器 "a 录制了一个宏，但是中间有个地方出了错。
    这时我可以使用 "ap 将这串命令粘贴下来，然后修改出错的地方，最后选择这串命令，通过 "ay 将它们复制回寄存器 "a 。
    这样，我们不用重新录制命令，就完成了宏的修改，是不是很方便？  
15_5 寄存器的分析 
 在正常模式（normal mode）下，我们使用 "reg 来引用某个寄存器。
 而在其它情况下，我们使用 @reg 来引用某个寄存器。 
 例如： 
    #正常模式，使用寄存器a来复制当前行"ayy
    #命令行模式，为寄存器a赋值:let @a="some text..."复制代码   

==============================================================
                    16 宏
==============================================================
16.1 宏的基本使用
    我要将下面这段代码
        foot = 'foot' 
        ball = 'ball' 
        football = foot + ball
    变为这样
        var foot = 'foot'; 
        var ball = 'ball'; 
        var football = foot + ball;
    我们可以利用之前介绍的.命令或者针对列的可视模式来处理，只是不管用哪种方法都需要至少两次操作。
    问题先放在这里，让我们先了解下什么是宏，以及怎么用宏。

    宏是存储在寄存器中的连续的操作指令，以便后续可以对这些指令进行回放。
    可以使用 q 进行录制，后面跟寄存器名称，表示将接下来的操作记录保存到这个寄存器中。
    例如使用 qa 表示将接下来的操作保存到 a 这个寄存器中。
    退出宏的录制可以直接输入 q

    针对上面的例子，我们可以执行 qa 进行宏的录制，然后使用 A 在行尾进入插入模式，接着输入 ; 完成行尾的操作。
    然后使用 I 进入行首，然后在行首输入 var 完成这部分的工作。
    最后使用 q 退出宏的录制。这样就将这个宏保存在了a 寄存器.
    我们可以使用 :reg a 来查看寄存器的内容。

    宏录制完成之后，可以使用 @ + 寄存器 来回放寄存器中保存的宏。
    在回放宏之后可以使用 @@ 来快速回放上一次回放的宏。

    到现在各位小伙伴可能已经发现了，它与.命令比较类似，只能机械的执行之前执行过的内容，它无法做到智能化，
    例如我在录制宏的过程中使用了诸如 2w之类的命令，后面在重复的时候很有可能发生错误。
    这就要求我们在使用宏的过程中，尽量规范化光标移动，不要搞这种特例的形式。

    这里我们还是手动执行了好多次同样的宏，宏与普通的operator 一行支持前面加数字表示重复，例如2@a 表示重复执行两次这个宏。
    上面的例子我们可以稍微做一下修改，即在最后添加一步将光标移动到下一行的操作——j。然后使用这个特性进行重复。
    
    vim 宏在 motion 执行失败之后会终止执行，这个并不是一个 bug，而是一个特性。
    我们不用关心剩下的操作需要重复多少次，只需要给出一个足够大的数，保证已有行能正常进行修改就可以了。

    我们再来看一个例子将

        1. one 
        2. two 
        3. three 
        4. four 
        5. five 
        6. six 
        7. seven 
        8. eight 
        9. nine 
        10. ten
    改为

        1) One 
        2) Two 
        3) Three 
        4) Four 
        5) Five 
        6) Six 
        7) Seven 
        8) Eight 
        9) Nine 
        10) Ten
    我们可以这么归纳这个操作，从行首开始找第一个 .，然后执行替换操作将其替换为 )。
    然后找到下一个单词，将首字母改为大写。
    我们可以在宏中执行 0f.r)w~j最后退出。
    读一下这段内容， ~之前没见过吧。之前介绍过，gU和 gu后面可以跟 motion表示将对应范围的字符转化为大写和小写。
    g~可以进行大小写反转。而这里的~直接将当前光标所在字符进行反转。

    上述命令我们首先使用 0将光标至于行首，这样就规范了每行的查找操作。
    另外这里由于 10 有两个字符，所以这里使用 f 来查找而不仅仅使用 l往后移动一个字符，
    最后我们不确定. 和单词之间会不会有空格。所以这里最好是使用 w 而不是 l 。
    这些细节体现了我们之前说的要更加规范的移动光标。

    宏录制完了之后，我们可以利用之前介绍的 motion失败会终止执行的特性，
    不用数需要处理多少行，直接 10@a（因为第一行已经处理了，所以这里只有9行待处理）

16.2 以并行的方式执行宏
    我们将上述例子进行变更

        1. one
        2. two
        3. three
        4. four  
        // do something five 
        6. six 
        7. seven 
        8. eight 
        9. nine 
        10. ten
    执行上次录制的宏，发现它在第5行的位置停止了，因为在第5行中未找到 .，所以它终止了，
    为了继续运行，需要手动跳过，然后继续执行。
    假设我们有多处有注释，每次遇到问题就停下来，再手工执行，会显得比较麻烦。
    为了解决这个问题，我们使用vim提供的另外一种执行宏的方式——以并行的方式执行。

    重新录制宏，与之前相比，只需要将j这个操作给去除掉。
    然后使用针对行的可视模式，选中待处理行，然后针对这些选中行来执行宏。
    我们在这里来审视一下这两种方式，串行方式需要提供重复次数，
    它是第一次执行完了接着执行下一次，下一次的执行依赖于上一次成功的执行。
    并行则不然，并行是针对选中部分，同时执行一个宏操作。即使中间有错也不影响其他行的运行。
        :startLine,endLine normal @a
    符合上面的格式即可，行可视模式只是方便确认执行范围(startLine,endLine)。

16.3 给宏追加命令
    还是上面的例子，假设在录制好了宏之后发现我们少了一个j，使用串行话的方式无法顺利执行。
    这种情况下不需要重新录制宏，只需要在对应寄存器中添加一条指令。

    这里补充一下寄存器相关知识。在上一篇介绍寄存器的时候我们只演示了使用小写字母的寄存器，没有提到大写字母的寄存器。
    根据之前的惯例，大写字母与小写字母都可以使用，大写字母的功能比小写字母要强，
    例如大写的标签标示全局，小写的只能用于单个文件。
    这里大写的寄存器与小写的寄存器是同一个寄存器，使用大写时我们可以对寄存器内容进行追加操作。
    宏是保存在寄存器中的，q 后面加字母表示宏的内容保存在哪个寄存器中，
    将命令追加到寄存器中使用 q+大写字母。

16.4 配合文件参数列表使用宏
    之前介绍过文件参数列表，即使用 :args 可以对文件进行分组，各位小伙伴可能只知道这个，但是没找到它的使用场景。
    也不知道vim提供这个功能有什么用处。在这里我们就来看看它的一个使用场景。
    例如：我要在每个lua文件中添加一行注释 --this is add by vim macro 。
        16.4.1 打开一个 lua 文件之后，使用 :args **/*.lua 来将每个 lua 文件加入到参数列表中。
        16.4.2 随意打开一个 lua 文件，在录制宏的时候执行 ggO<ESC>S--this is add by vim macro 然后退出。
                我们先用 gg 移动到第一行，以便能准确的在首行插入内容。
                由于在 lua 文件中有注释的话使用 O 添加一行的时候它会自动添加一个注释。
                但是不能确保所有的 lua 文件在行首都有注释，所以我们先使用 S 删除一行并进入插入模式。
                此时文件已经发生了变化，如果我们直接执行宏的话，之前录制时修改的文件将会两次执行相同的命令，
                所以这里不能保存，可以执行 :edit! 放弃本次修改，或者如果已经修改了的，可以执行u进行回退。
        16.4.3 命令模式中执行普通模式的命令 :argdo normal @a 。argdo 表示循环对参数列表中的每个文件执行相同的操作。
    上述的操作方式采用的是并行的执行宏，我们可以对其进行一些修改，让其支持串行的方式。
    我们可以使用 :next 来访问下一个，:prev 来访问上一个。
    配合之前的命令可以使用 ggO<Esc>S--this is add by vim macro:next。
    我们无法知道参数列表中到底有多少个文件，但是可以利用失败即终止这个特性输入一个足够大的数字即可，
    例如 100@a即可。这样就省去了执行命令模式中命令的相关操作。
    对比两个宏发现我只需要在之前的宏后面添加一个 :next 指令即可，所以这里就直接执行了 qA:nextq

    对比上面两种方式发现，并行执行的时候中间某个缓冲区如果出错并不影响其他缓冲区的执行，
    这就给我们排查造成了一定的问题，一旦出错我们不得不打开每一个缓冲区查看执行的结果来找到出错的位置。
    而串行则会停在出错的位置，我们只要针对出错的部分做一定的调整，然后继续执行就好了。
    而且这个例子中列表参数并不会循环遍历，也就不用担心之前修改过的内容又被修改。

16.4 编辑宏内容
    上面我们说到宏是保存在寄存器中的一组操作指令，可以利用往寄存器中追加内容的方式往宏中追加指令，
    同样也可以重新编辑更新寄存器中的内容，在执行宏的时候命令就会改变。
    以上面那个添加注释的例子为例，假设忘记了删除新添加的 --，
    也就是我录入的宏变成了 ggOthis is add by vim macro ，
    我们会发现在第一行是注释的文本中它的表现是正常的，
    但是第一行不是注释，添加的就是有问题的，例如 nvim-config/lua/config/auto-session.lua。
    我们发现了这个问题需要对这个宏进行修改。

    首先我们需要将宏从寄存器中放到编辑器中，这就要使用 :put a取出寄存器中的内容，
    你可能会疑惑为什么不用 "ap 呢，这是因为 p 命令默认会将寄存器中的内容放到光标所在位置的后面，
    而 :put 则会直接放到下一行，所以这里还是放入到当前命令之后要好。
    接着修改一下这个宏。在对应位置加上 S 这个操作，最后使用 0d$ 从行首粘贴到行尾，
    注意这里尽量不要使用 dd，它会连带着换行符一块进行粘贴，可能会破坏宏的指令。
    最后我们可以先删除之前粘贴的一行，再重新执行这个宏


==============================================================
                    17 查找模式
==============================================================
vim有普通模式、插入模式、可视模式和命令行模式，除了这几个模式以外，vim还有一个非常强大的模式——查找模式。

17.1 查找模式使用   
    我们可以在普通模式下输入 / 进入插入模式。
    在其后面输入想要查找的字符串，按下<CR> 进行查找。
    此时vim光标会自动跳转到匹配的位置，
    并将对应位置高亮显示( 这个是 neovim的特性，vim高亮可能需要一些配置)。
    使用 <Esc> 将会结束查找，退回到普通模式。

    在匹配模式中，可以使用 n 来跳转到下一个匹配位置，按下N 将跳转到上一个匹配位置。
    这个查找是循环进行的，也就说在跳转到最后一个匹配位置之后，再使用 n 将会跳转到第一个匹配位置。  

    我们可以使用 wrapscan 这个选项关闭这一特性，例如在neovim 中使用如下代码
        vim.o.wrapscan = false
    或者在vim中使用这样的代码
        set nowrapscan
    在查找模式中，可以使用 <UP> (也就是方向键) 来遍历之前查找项。

17.2 取消高亮的匹配
    vim 中可以使用 hlsearch 来设置将匹配项进行高亮显示( neovim 则默认支持该项) 。
    高亮显示匹配项这个特征在我们寻找这些匹配项的位置时十分有用，
    但是一旦找到想去的地方之后，这些高亮显示的内容却会干扰我们的视线，特别是匹配项过多的时候。
    这个时候我们可以使用 noh 来取消高亮。但是每次这么输入比较麻烦，我们可以绑定一个快捷键，快速取消高亮。
    这里还是等到介绍配置的时候再介绍吧。  

17.3 执行前预览第一处匹配
    在一般的vim中，一定要等到输入完完整的内容，然后按下 <CR> 键之后才会进行匹配，
    而执行前预览会在每次有新输入的时候更新匹配。
    输入 s 的时候，所有 s 字符都被选中，输入后面的内容时再次匹配，只高亮匹配上的。

17.4 快速选中光标所在单词进行搜索
    这里主要为了介绍 *这个命令，当光标处于目标单词的时候，按下 * 将直接进行搜索。

17.5 将光标移动到匹配的结尾
    默认情况下，使用匹配模式时，光标都在匹配字符串的开头位置，
    我们可以在搜索结尾处添加 /e 来让vim将光标移动到匹配字符串的结尾处。

==============================================================
                    18 查找模式进阶
==============================================================
18.1 调整大小写敏感
    默认情况下，在搜索时是大小写敏感的
    可以使用 ignorecase 项来取消大小写敏感，例如在 neovim 中写上如下配置
        vim.o.ignorecase = true
    或者在 vim 的配置文件中写上
        set ignorecase
    此时在输入 require 时，发现已经可以匹配到 REQUIRE 了

    但是在实际使用中我们希望有时候大小写敏感，有时候大小写不敏感，
    例如想模糊搜索某个函数或者变量的时候。更好的做法是设置 smartcase 项。
    它只有在输入的字符中有大写才启用大小写敏感，否则就是大小写不敏感。
        vim.o.smartcase = true
        set smartcase
    当然我们也可以在每次搜索的时候单独指定本次搜索是否大小写敏感。
    可以在匹配时输入\c来不区分大小写而使用 \C 区分大小写，这个符号可以出现在任何位置，
    哪怕你输入 /requ\Cire 它也能正确找到所有的 require字符串。

18.2 使用正则表达式匹配
    vim支持正则表达式的搜索，vim采用的是 POXIS 的正则表达式的规则，
    这就让我们一些习惯 Perl 正则表达式规则的人在使用时会出现一些不适宜。
    现在我们来看一个具体的例子

    假设现在有一个 css 文件, 我需要搜索里面的16进制颜色

        body { color: #3c3c3c; } 
        a { color: #0000EE; } 
        strong { color: #000; }
    我们在搜索时输入这样一个正则表达式 #([0-9a-fA-F]{6}|[0-9a-fA-F]{3}) 。
    发现它会报错，但是正则表达式来看，这么写是没问题的，
    我们要匹配的是以 # 开头，后面有6个或者3个16进制数的字符。

    这是因为里面有特殊字符，需要进行转义，例如 () 在 vim 中有特殊用途,我们将在接下来介绍它的用途。
    我们需要将正则表达式写成这样 #\([0-9a-fA-F]\{6\}\|[0-9a-fA-F]\{3\}\)

    好家伙，反斜杠居然有7个，而且 ()、{} 需要转义，而 [] 不需要转义。
    正则表达式就够麻烦的了，还得记住vim与其他编辑器的不同，用一次人就麻了。
    好在vim提供了 very magic 模式，即除了 _ 、 数字、字母之外的所有字符都具有特殊含义，
    这样我们就不用纠结哪些需要转义，哪些不需要了。
    可以在搜索的开头添加 \v 来启用这一模式，即我们可以输入 
        \v#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})
    我们还可以使用 \x 表示16进制数，以便简化上述正则表达式, 
        \v#(\x{6}|\x{3})。
    \x 是vim 字符类中的一个成员，我认为比较有用的还有如下这些

            字符	含义
            \x	十六进制数
            \X	非十六进制数
            \d	数字
            \D	非数字
            \o	八进制数
            \o	非八进制数
            \w	包括字母、数字和 _
            \W	不包括 字母、数字和 _
            \h	包括 字母和 _
            \H	不包括字母和 _
            \l	小写字母
            \L	非小写字母
            \u	大写字母
            \U	非大写字母

    除了有 very magic模式，vim 中还有 very nomagic 模式，
    在该模式中所有的字符都只表示它自身，没有特殊含义，
    例如 . 在正则表达中表示单个字符，
    但是在 very nomagic 模式中它就表示一个点，它可以匹配点这个字符本身，
    要启用 very nomagic 模式，可以使用 \V 作为前缀。

    使用括号获取子匹配项

    在 vim 中可以使用 <(\w+)\_s+\1> 来匹配重复单词，例如

        I love python 
        python is so good
    这句话中我们可以匹配到 python 这个单词。

    我们来看这个正则表达式，<> 匹配以某些字符开头或者结尾的单词，例如 
    <Py 将匹配所有以 Py 开头的单词，而 
    on> 将匹配所有以 on 结尾的单词，
    因为这里我们的需求并没有要求要匹配以某些字符开头的单词，加上这个就限定我们要
    <> 匹配单词而不是某些个字符。
    \_ 后面可以加vim字符类中的任意字符，代表在原来的基础之上额外再匹配换行符，
    例如 \x 可以匹配16进制数，\_x 可以匹配16进制数和换行符。
    \_s+就是匹配 <Tab> 空白字符和换行符，并且是匹配1个或者多个。

    在vim中使用括号代表子匹配项，它是整个正则表达式匹配的一个子项，
    例如 Py(tho)n 它可以匹配到 Python 和 Python 字符串里面的 tho。
    \后面加数字代表第几个匹配项，第0个匹配项是整个正则表达式的匹配项，
    1、2、3、…、n 则对应着第1个子匹配项，第二个、第n个子匹配项。

    了解了这些，我们就能读懂整个这个正则表达了，它匹配这样一个单词：
    他是任意单词，但是它后面需要出现一个跟他一样的单词，不管中间包含的是多个空格、制表符或者换行符。

    如果我们只是想匹配是否有多个重复的 Python可以这样写： (<Py\w+on>)\_s+\1




    18.3 界定匹配范围

        在搜索模式中，vim把查找域中输入的内容（可以是正则表达或者是原意匹配的字符串）和它匹配的到的高亮的文本进行了区分。
        一般将查找域中的内容称之为模式，将被高亮显示的文本称之为匹配。
        一个模式可以对应多个匹配（这里的模式与前面提到的普通模式和插入模式的意思不同）。

        一个匹配的边界通常对应着一个模式的起始与结尾。例如 
        <> 表示一个匹配的边界将是一个单词。
        除了这个，vim提供了 \zs 和 \ze 这两个元字符来对一个匹配进行裁剪。
        \zs 表示去掉匹配中开头的指定部分，
        \ze 表示去掉匹配中结尾的指定部分。

        例如在上面这句话中，我通过 <\w+> 匹配到所有的单词。
        然后通过 <\zsPy\w+> 来对匹配内容进行裁剪，将高亮显示所有单词 Py 以及后面的内容，
        如果不是以 Py 开头的则完全被裁剪掉了。
        或者使用 <\w+\zeon> 来裁剪，只显示所有单词 on 前面的部分。
        
    18.4 转义特殊字符

        这里我们用一个URL 作为例子来演示
            https://www.baidu.com/search?q=\\/
        假设我们要匹配所有文档中出现的这个url，该如何做呢？
        首先考虑在匹配模式中输入一大串的内容，但是这一大串不需要手工输入。我们可以将vim的命令模式和现在的匹配模式看成一个特殊的插入模式中的文本，这样我们就可以使用前面介绍的在输入模式中使用寄存器的例子。先使用 "iy$ 粘贴一行，然后在匹配模式中使用 <Ctrl+r>i 来粘贴。

        但是这个时候我们发现匹配的结果并不是我们想要的，这是因为在匹配模式中 / 是具有特殊意义的特殊字符，我们需要告诉vim将其解释为普通字符，这个时候可以使用 \V 来进入 very nomagic 模式，该模式与 very magic 相反，将所有字符作为普通字符来解释。

        我们会返现它只匹配到了 https:，并且模式中的字符串也变成了 https: , 后面从/开始截断了，这时候我们可以使用 \/ 对 // 进行转换。同时 \ 本身也作为特殊字符，我们也需要对其进行转义。即整个匹配应该输入 https:\/\/www.baidu.com\/search?q=\\\\\/

        
        如果需要找出包含空格的空行，那么可以使用^\s.*$表达式；如果需要找到没有空格的空行，则可以使用\S
        \s\+$可以匹配尾部的空格； \+\ze\t则可以匹配Tab制表符之前的空格。（请注意，此表达式开头为空格）

================================================================================================
            18_ VIM学习笔记 正则表达式-进阶（Regular Expression Advanced）
=================================================================================================


18_1 范围（Character Ranges）
    []通配符，表示只可以匹配方括号内列表的字符。
    例如t[aeiou]n将匹配一个小写元音字符，可以找到tan,ten,tin,ton,tun。

    在方括号内，可以通过短横线来指明包括字符或数字的范围。
    例如[0-9]可以匹配0到9中的任一数字。
    我们还可以组合其他字符，例如[0-9aeiou]可以匹配任意一个数字或是小写的元音字符。
    如果需要匹配"-"本身，那么需要使用反斜杠进行转义。
    例如表达式one[\-]way可以匹配one-way，但不会匹配one way。

    范围通配符:
        [abc]       匹配a,b或是c
        [^abc]      匹配除abc以处的字符
        [a-z]       匹配从a到z的所有小写字符
        [a-zA-Z]    匹配所有大小写字符
        
18_2 排除（Excluding）  
    ^通配符，可以排除指定的字符。
        acme[^0-9]
        匹配所有包含acme，后跟一个非数字字符的行。
        但不会匹配以acme结尾的行，因为模式中的acme之后必须有一个字符。

        ^[^a-zA-Z]
        匹配以非字母开头的行，但不会匹配空行，因为行中必须有一个非字母字符存在。

        如果需要匹配"^"本身，那么需要使用反斜杠进行转义。
        例如表达式2[\^*]4可以匹配2^4和2*4。

18_3 重复次数（Repeat Modifiers）
    {minimum,maximum}
        表达式指出一个字符重复的次数。例如表达式a\{3,5}可以匹配3到5个a（aaa，aaaa，aaaaa）。
        Vim默认是会尽可能多地进行匹配（Matching as much as possible）。
        在表达式中，最小次数是可以省略的，即默认最小次数为0，所以表达式a\{,5}可以匹配0到5个a。
        最大次数也是可以省略的，即默认匹配无穷大，所以表达式a\{3,}最少可以匹配3个a，最多个数没有限制。

    {number}
        表达式只指定一个数字，Vim就会精确的匹配相应的次数。例如a\{5}只会精确的匹配5次。

    {-minimum,maximum}
    在数字前增加一个负号(-)，那么Vim在查找时就会尽可能少地进行匹配（Matching as little as possible）。
    例如ab\{-1,3}将只匹配 "abbb"中的"ab"。表达式a\{-3,}可以匹配三个或是更多个a，但尽可能少地进行匹配。
    而表达式a\{-,5}可以匹配0到5个字符。
    表达式a\{-5}将会精确的匹配5个字符。

    重复通配符:
            *	    匹配0次或是多次，尽可能多的匹配
            \+	    匹配1次或是多次，尽可能多的匹配
            \=	    匹配0次或是1次，尽可能多的匹配
            \{}	    匹配0次或是多次，尽可能多的匹配
            \{n}	精确匹配n次
            \{-n}	匹配n次
            \{n,m}	匹配n次到m次，尽可能多的匹配
            \{n,}	匹配n次到多次，尽可能多的匹配
            \{,m}	匹配0次到m次，尽可能多的匹配
            \{-n,m}	匹配n次到m次，尽可能少的进行匹配配
            \{-n,}	至少匹配n次，尽可能少的进行匹配
            \{-,m}	匹配到m次，尽可能少的进行匹配
            {-}	    匹配0次到多次，尽可能少的进行匹配

18_4 捕获组（Groups）
    ()用于保证需要组合出现的字符。表达式a\(XY\)*b将会匹配ab, aXYb, aXYXYb, aXYXYXYb。

    让我们通过一个示例来说明捕获的作用。
    假设你有一个文本文件，其中包含一些电子邮件地址，你希望从中提取用户名和域名。
    以下是一个示例文本文件：
        Alice's email: alice@example.com
        Bob's email: bob@gmail.com
        Charlie's email: charlie@example.net
    你可以使用正则表达式来捕获用户名和域名。
    在这个例子中，我们使用的正则表达式是 (\w+)@(\w+\.\w+)，
    它包含了两个捕获组，分别捕获用户名和域名。

    (\w+)：这是第一个捕获组，它匹配一个或多个单词字符（字母、数字、下划线），表示用户名。
    @：匹配 "@" 字符。
    (\w+\.\w+)：这是第二个捕获组，它匹配一个或多个单词字符，接着是一个点号，然后再匹配一个或多个单词字符，表示域名。
    现在，让我们使用这个正则表达式来提取用户名和域名：
        :%s/(\w+)@(\w+\.\w+)/Username: \1, Domain: \2/g

        (、)、+ 要加转义字符，修改为：
            :%s/\(\w\+\)@\(\w+.\w\\+\)/name:\1, domain:\2/g 
        或用\v模式,(、)、+ 不需要转义字符，但@需要：
            :%s/\v(\w+)\@(\w+.\w+)/name:\1, domain:\2/g





    (\w+)：这是第一个捕获组，它匹配一个或多个单词字符（字母、数字、下划线），表示用户名。
    @：匹配 "@" 字符。
    (\w+\.\w+)：这是第二个捕获组，它匹配一个或多个单词字符，接着是一个点号，然后再匹配一个或多个单词字符，表示域名。
    现在，让我们使用这个正则表达式来提取用户名和域名：

    这个 Vim 命令会查找文本文件中的匹配项，并将它们替换为带有用户名和域名的格式。
    在这个命令中，\1 表示第一个捕获组（用户名），\2 表示第二个捕获组（域名）。
    执行命令后，文本会被修改为：
        Alice's email: Username: alice, Domain: example.com
        Bob's email: Username: bob, Domain: gmail.com
        Charlie's email: Username: charlie, Domain: example.net


以下是一个示例文本文件：
18_5 或操作（Alternation Operator）
    |用于查找两个或是多个可能的匹配。
    例如表达式foo\|bar可以找到foo或是bar。
    我们可以连接使用多个或运算符，例如表达式Larry\|Moe\|Curly将找到Larry、Moe和Curly。
    而表达式end\(if\|while\|for\)则可以匹配"endif", "endwhile" 和 "endfor"几个不同的元素组合。

    如果希望匹配多次，那么可以组合使用加号和括号运算符。
    例如表达式/\(foo\|bar\)\+可以匹配 "foo", "foobar", "foofoo", "barfoobar"等等。
 
18_6 特殊字符元素（Special Character Atoms）

            \a	大小写字母字符[a-zA-2]
            \A	除了a-zA-Z以外的字母字符
            \b	<BS>
            \d	数字字符 [0-9]
            \D	非数字字符 [^0-9]
            \e	<ESC>
            \f	由isfname选项定义的文件名字符
            \F	文件名字符，但是不包含数字
            \h	单词的头字符(A-Za-z)
            \H	不是单词的头字符(A-Za-z)
            \i	由isdent选项定义的字符
            \I	定义的字符,但是不包括数字
            \k	由iskeyword选项定义的关键字字符
            \K	关键字字符，但是不包括数字
            \l	小写字符 [a-z]
            \L	非小与字付 [^a-z]
            \o	八进制数字
            \O	非八进制数字
            \p	由isprint选项定义的可打印字符
            \P	可打印字符，但是不包括数字
            \r	<CR>
            \s	空白符<Space>和<Tab>[ ]
            \S	非空白符 [^ ]
            \t	<Tab>
            \u	大写字母字符[A-Z]
            \U	非大写字母字符[^A-Z]
            \w	单词字符(0-9A-Za-z)
            \W	非单词字符
            \x	十六进制数字[0-9a-fA-F]
            \X	非十六进制数字[^0-9a-fA-F]
            \~	匹配最后指定的字符串
            \_+特殊字符(\_s,\_.表示在原来的基础上添加换行符)
            \n 换行符
    表达式\a匹配任意字符，
    而表达式\a\a\a则可以匹配任意三个字符。
    而\a\a\a_则可以匹配任意后带一个下划线的三个字符。
    操作符\d可以匹配任意数字；
    \d\d\d\d则可以匹配任意四个数字（即使其为更长数字串中的一部分）。
    如果希望精确匹配四位数字，那么可以使用以下任一命令：
        /\<\d\d\d\d\>
        /\<\d\{4}\>
        /\v<\d{4}>

    \u可以匹配任意大写字符；
    \U则可以匹配任意非大写字符。
    使用以下命令，可以将整篇文本替换为大写字母：
        :%s/.*/\U&/

    仅将行首字母转换为大写字母，而保留其他字符不变。
        :%s/.*/\u&/
    如果需要找出包含空格的空行，那么可以使用\s.*$表达式；
    如果需要找到没有空格的空行，则可以使用^\S\=$ 
    空格行没有行尾标识"$",但有行首标识"^"。

    \s\+$可以匹配尾部的空格； 
     \+\ze\t则可以匹配Tab制表符之前的空格。（请注意，此表达式开头为空格，前面有\zs与\ze相对）
    

    请注意，以上预定义字符是不能内嵌在[]中使用的。
    例如，表达式[\d\l]是错误的，应使用\(\d\|\l\)表达式匹配数字或小写字符。
    [] 用在范围通配符，不能用在特殊字符元素

18_17 预定义字符类（Character Classes）
    如果我们想要查找所有大写字符，可以使用表达式
    [A-Z]，或者使用预定义的字符类[:upper:]。
    使用/[[:upper:]](或/[A-Z])命令可以匹配所有大写字母；
    而使用/[[:upper:][:lower:]]命令则可以匹配包括大写和小写字母在内的所有字母。

18_18  转义符（Escaped Characters ）
    如果需要查找某些特殊符号（比如美元符号），那么可以使用反斜杠backslash（\）进行转义。
    例如：表达式\$可以匹配美元符号（$），而表达式\^则可以匹配脱字符（^）。
    需要注意的是，反斜杠backslash（\）本身也是特殊符号，所以需要用两个反斜杠\\来匹配。

18_19 帮助信息（Help）
    可以使用以下命令，查看关于查找模式的更多帮助信息：
        :help pattern


================================================================================================
                19 替换
=================================================================================================

19.1 substitute 简介
   
    substitute 允许我们先查找一段文本并用新的文本将匹配上的文本进行替换。
    它的使用比较复杂，需要提供一个匹配模式和一个替换的字符串。
    命令格式如下：
        :[range]s[ubstitute]/{pattern}/{string}/{flag}
    range 
        表示范围，与之前介绍的其他 ex 命令中范围的作用一样。
    pattern 
        表示一个匹配模式，回忆一下之前说过的，这里的模式跟之前介绍的普通模式、插入模式的含义不同，
        它代表的是一串用来进行匹配并高亮显示的字符串。
    string
        是一串用来进行替换的字符串，将匹配项都替换成某项。
    flag
        是一些替换的标志，我们将在后面的内容中进行介绍。


    例如 :%s/python/Python/g 
        表示在整个文件中将 python都替换为 Python
        (这么长时间没怎么提到 ex 命令了，不知道各位小伙伴是否还记得 %代表当前打开的文件)。
        g 是一个标志位，表示修改整行中的所有匹配项，而不仅仅是修改第一个匹配项。

    标志位
        上面的例子中我们使用了一个 g 作为标志位，其实还有其他的标志位。
        我们可以通过标志位灵活的定义 substitute 的行为。
        下面是一些常用的标志位：//不对的

            \r：插入一个换行符
            \t：插入一个制表符
            \\：插入一个反斜杠
            \1：插入第一个子匹配项
            \2：插入第二个子匹配项
            \0：插入匹配模式的所有内容
            &：与 \0用法相同
            ~：使用上一次调用 substitute时提供的 string内容
            \={vim script}：执行 vim script并将返回内容作为 string

            g：全局替换，即替换每一行中所有匹配的文本，而不仅仅是第一个匹配。
            c：交互替换，每次替换前会询问是否替换。
            i：不区分大小写匹配。
            n：只替换第 n 个匹配项。
            i：不区分大小写匹配。
            g：全局匹配，匹配所有匹配项而不仅仅是第一个。
            m：多行匹配，影响 ^ 和 $ 的行为，使其匹配每行的开头和结尾。
            s：单行匹配，使 . 元字符匹配包括换行符在内的所有字符。
            x：忽略空白，允许在正则表达式中使用空格和注释，以提高可读性。
            U：非贪婪匹配，使匹配尽可能少的字符。
            /c 表示确认替换，它允许您逐个确认是否替换每个匹配项。


    有这么多标志位，该怎么记，平时怎么用到呢？别急，下面将通过相应的示例来演示如何使用它们，我们完全可以在日常使用中学会它们。

    示例
    使用 g 替换所有内容
        how can I learn python very good, just use it more and more. 
        python is very powerful, you can just learn python within your work.
    我们将上面文本中的所有 python 都改为 vim 。我们先来看看不使用标志是什么样子的。
    即这里输入 :%s/python/vim

    我们发现它只替换了每一行的第一个出现 python 的地方，同一行后面的 python 不受影响。
    这里我们使用 /g 替换每一处出现 python 的地方。
    g 这个标志很容易联想到 global 这个单词，应该表示的是整个选中的文本范围，
    而我们前面已经选定了当前文件中的所有文本，似乎看起来很合理。
    但是 g 作用范围应该是整行，而我们选中的是文本中的所有行。
    看起来效果是一样，但是理解起来确实有差距。
    为什么它会作用于行，我想应该是 vim 发源于 ed 这个编辑器，vim的 ex 命令起源于 ed 编辑器，
    而后者是一个行编辑器，所以大部分的命令都作用于行。这样应该就能说得通了。

19.2 手动选择是否需要替换
    有的时候我们并不希望盲目的对所有内容进行替换，而只替换其中的部分内容。
    例如上述的文本中，我们只想替换第二行的最后一个 python 为vim。
    那么可以使用 c 标志。你可以理解为comfirm?。
    vim会询问我们是否需要进行替换。即我们在这里输入 
    :%s/python/vim/gc。后面可以按下 y 来确定替换，n 表示不进行替换并切换到下一处匹配。
    因此这里我们可以输入 nny

    其实不光 yn 这两个选项，从vim的提示看总共有 ynaql 和 <Ctrl +e>以及 <Ctrl + y>。
    它们的含义如下：

        y：替换本处匹配
        n：不替换本处匹配
        a：替换此处之后的所有匹配项，随后退出本次替换
        q：退出本次匹配
        l：替换此处之后退出本次替换
        <Ctrl + e>：向上翻滚屏幕
        <Ctrl + y>：向下翻滚屏幕

19.3 重用上次匹配模式
    如果我们将 {pattern} 部分留空，那么vim会重用上次的 {pattern} 。下面我们使用一个例子来看如何使用这一特性。

        #define VERSION "v1.01" 
        #define TITLE "vim" 
        #define PATH "~/.config/nvim"
    我们想将里面的字符串改为宽字符，也就是在双引号前加L,我们首先要匹配所有的引号内容。
    很多时候正则表达式比较复杂，无法一次就写对的，所以这里我们分步骤来，
    首先正确写出正则表达式匹配出所有带双引号的字符串。 /\v"(.*)" 可以获取所有的字符串。

    接着我们使用上面的这个模式来进行替换，即输入 :%s//L\0/gc。
    当然这里只有这么三行一眼就知道我们要替换所有，但是代码一长了，就需要我们来确认是否需要替换。

    复杂的正则表达式我们无法一次就输对，
    如果进行替换操作的时候因为正则表达式输入不对导致每次都得重新输入一堆内容就显得比较麻烦了。
    而且如果使用 substitute 命令之后才发现错了，又得撤销重新输入那么大一串。
    与 substitute 相比，查找模式不会修改文本，我们可以在查找模式中使用 <Up> 慢慢修改直到满意为止。
    当模式对了，下面就可以利用 {pattern} 留空这种方式来重用上次模式。

    需要注意的是将模式留空，将会在历史命令中留下一个不完整的记录，模式与命令是独立存储的。
    在上面的例子中，如果我又执行了新的匹配，例如我想查找所有 define，后面使用 重新执行命令的时候，发现匹配的内容变了。
    有一个办法就是将上次的模式存储到寄存器中，在匹配的时候从寄存器中取数据填充 {pattern} 部分。

    命令窗口：
        上次匹配成功之后如何将对应的模式放到寄存器呢，这里我们介绍一个新的内容——命令窗口。
        命令窗口是一个显示历史命令的缓冲区，它跟普通的缓冲区区别仅仅在于它显示的是历史命令而已。
        使用 q: 可以调出命令模式历史命令窗口，
        使用 q/ 可以调出搜索模式历史命令窗口，
        这里我们可以使用 q/ 调出搜索模式的历史命令窗口。
        在对应模式行使用 "iy$ 来粘贴一行，然后在最后替换时使用 <C-r>i 来填充 {pattern}。

19.4 使用寄存器的内容进行替换
    {pattern} 域留空了，vim会自动以上一次的模式来进行匹配，
    那么如果我把替换域留空，是不是会以上次替换的字符串作为这次的进行替换呢？
    试验过后发现 vim 并不会这样做，它会使用空字符串进行替换。
    (单纯的使用上次的替换字符串使用的是 ~ 这个符号)。
    如果想要快速填充替换域，可以先进行复制，然后在 substitute 中使用0 寄存器。
    即，我们可以输入 :%s/{pattern}/<C-r>0/gc 来完成替换。就像上面的例子那样。

    但是这种方式有一种缺陷，那就是如果复制的内容中有 / & 之类的特殊符号的话，它会出现错误。
    这个时候我们可以手动编辑寄存器中的内容，对特殊符号进行转义。
    这个时候我们会想有没有什么办法能让vim知道我只想将寄存器中的特殊符号作为普通字符串呢？
    当然是有办法的，我们可以借助vim script 来实现这一需求。
    我们可以输入 :%s/{pattern}/\=@0/gc，其中 
    \=是我们之前列举的使用 vim script，而后面的 
    @0 则是 vim script 的内容，表示取 0 寄存器的内容。
    这里出现了 vim script的内容，不过不用担心，这里涉及到的都是最简单的vim script内容，
    

19.5 使用上一次的 substitute 命令
    假设我们在执行 substitute命令的时候忘记了在前面添加 %，我们当然可以使用 <Up> 键来在上一次的基础之上进行修改。
    这里介绍一个更简单的方式，可以在普通模式中输入 
    g& 它会在整个文件中重新执行上一条 substitute命令。它等效于 
    :%s//~/&。当你其他部分都正确，唯独忘了添加 %可以考虑使用这条命令。

    在介绍命令模式的时候介绍过，大部分的 ex 命令都可以使用选择模式中选中部分作为命令执行的范围，substitute 同样可以。
    我们先选中后面要更改的部分，然后使用 :&&来在选中部分重复执行上一次的 substitute 命令。
    这两个 &具有不同的含义，第一个 & 表示重复上次执行的 substitute 命令，
    但是它不包含上次指定的标志位，在后面再加一个 & 表示重复上一次的标志位。
    后面的 &与上面介绍的 g&中的 &含义相同。

19.6 使用子匹配进行替换
    假设我有这么一份联系人记录

        Jack Ma, 12398988011 
        Pony Ma, 16528649018 
        Donald Trump, 15092838173 
        Joe Biden, 18571820986
    现在我想改变一下顺序，让电话号码在前，人名在后。
    首先构造一个可以准确匹配到人名和电话号码的正则表达式： 
    (.*),\s+(\d{11}) 。
    第一个括号匹配的是人名，第二个括号匹配的是电话号码的11位整数。
    然后我们可以利用之前介绍的 {pattern} 留空的方式，重新组织新的排列格式 :%s//\2, \1

    //\v(\s+|\w+),\s+(\d{11}),
        此语句前面一个()只能捕获Ma Ma Trup Biden，不知道为什么
    //\v((\s|\w)+),\s+(\d{11}) ,
        此表达式可以满足要求，但名称需要是\1,\2是最后一个字母，电话是\3
    

19.7 使用 vimscript 脚本
    在上面介绍从寄存器中读取内容进行替换的时候初步介绍了，使用 vimscript 的例子。
    这里我们再举出一个使用 vimscript 的例子，不过不用慌，使用的脚本都极为简单，不存在理解障碍。

    假设有这么一段HTML代码

        <h2> this is a h2 tag</h2> 
        <h3> this is a h3 tag</h3> 
        <h4> this is a h4 tag</h4> 
        <h5> this is a h5 tag</h5>
    我们希望对标题标签进行升级，换句话说就是将 <h2>，提升为 <h1>，<h3> 提升为 <h2>。

    首先我们构造模式来匹配对应的数字，可以用 \d 来匹配数字，但是它会匹配到所有数字，
    因此我们加一个限定，只匹配以 <h 或者 </h开头的数字，这个时候正则表达式可以改为 \<\/?h\d，
    我们只想要后面的数字，因此可以对这个匹配进行裁剪，\<\/?h\zs\d。 \v\<\/?h\zs\d\ze\>(z这样更好)
    这样就匹配到了所有标签后的数字，但是内容里面的数字没有被匹配。

    vimscript 命令——submatch
       它接收一个表示第几个匹配的参数，返回对应的匹配项。
       我们可以使用这个函数将获取的每个匹配项都 -1，即输入 
       :%s//\=submatch(0)-1/g 就可以完成这个操作了。

 
各位小伙伴可能还会有疑惑，目前介绍的查找替换似乎只针对的是某个文件，
如果我想在项目中进行全局替换该怎么办呢？
请各位想想之前我们是如何在多个文件中执行宏的。用argdo 命令
至于多个文件进行查找，我们将在后面的部分继续介绍。

 ================================================================================================
                20 global 命令
=================================================================================================   
    
    
在前面的文章中，我们介绍了如何进行查找和替换，而替换是建立在查找基础之上的一个简单的应用，
它只是将匹配文本修改为另一个。那么vim中还能针对匹配上的文本做哪些操作呢？
在本篇文章中我们来对这个问题进行探讨。

20.1 初识global 命令
    我们能够对存在匹配项的行进行其他操作的关键在于 global 命令。
    global 命令的作用是存在匹配项的行上执行指定的ex命令。命令的格式如下:

    :[range] g[lobal][!]/{pattern}/[cmd]


    与大多数ex命令一样，它接收一个作用范围。
    如果不给范围，则默认作用于整个文件，即它默认范围是 %
    ! 代表取反，是在不存在匹配项的行上执行ex命令;(g!可以用v替代)
    pattern 表示匹配模式
    cmd表示将在对应文本上执行哪些ex命令。如果不指定则默认执行 print命令


    这里需要强调的是，执行ex 命令操作的是有匹配项的行。
    操作的不是高亮的文本，而是有高亮文本的行。

    我们还是以一个简单的例子来演示如何使用

        #define VERSION "v1.0.1" 
        char pszVersion[] = VERSION; 
        #define TITLE "vim" 
        char* pszTitle = TITLE; 
        #define AUTHOR "Bram Moolenaar" 
        char* pszAuthor = AUTHOR;

    假设有这么一段代码，我们先用 ".*" 来匹配一个字符串，然后执行 :g//d 来执行删除操作。

    我们发现它并不是删除了后面的字符串而是将所有有字符串的行都删除了，只保留了赋值语句。
    相信通过这个例子各位小伙伴应该已经理解global 命令是如何作用的。
    如果我们要删除上述代码中所有的赋值语句，可以利用 !来进行取反，:g!//d  

    在 《vim 实用技巧》这本书中提到一个很有意思的东西。
    通过上面的描述，可以总结出 global命令的一个简写形式 
    :g/re/p 其中 g是 global命令的缩写，re代表正则表达式 regular expression, 而 p 则是 print的缩写。
    我们将 / 从中去掉就发现这个简写变成了 grep 这个单词。这也就是 grep 这个命令的由来。
    上面的内容已经初步介绍了 global 命令的使用，下面再来看看其他的使用场景。

20.2 配合缓冲区参数列表使用
    我们还是用 neovim 的配置文件。
    我们随机在部分 lua 文件中加一些 TODO 的注释。表示暂时未做将来会实现的功能。
    我们先在某个文件中查找 TODO字样，/TODO
    有的文件显示没有找到也不要紧，只是为了保存这个模式,
    然后将所有的 lua 文件加入到参数列表中，:args **/.*lua

    然后选择清空一个寄存器 qaq ，其中 qa 代表我们将要使用 a 寄存器来录制一个宏，
    不输入任何内容直接使用 q 结束录制。
    因为宏就是将操作内容写入寄存器，所以不进行任何操作的宏就可以清除寄存器的内容。

    然后执行 :argdo g//yank A 这里使用 yank 这个命令来复制内容到寄存器。
    另外使用了 A 而不是 a 因为这里是对每个文件依次执行命令的，
    需要一个个的添加到寄存器里面。所以这里使用大写字母。

    此时可以查看 a 寄存器的内容，发现已经有对应内容了。
    提取出来的内容有一个缺点就是无法显示具体是哪个文件中的 todo 项。
    将未来要实现但是现在没实现的功能用 TODO 描述出来在编程中是一个很常见的习惯，
    针对这个功能有许多做的不错的插件，后续将会介绍相关插件。

    以下是一些示例用法：
        1. 删除所有包含 "foo" 的行：
            :g/foo/d
            
        2.在所有包含 "error" 的行之后插入一行 "FIXED"：
            :g/error/normal oFIXED //嵌套nomal命令
            
        3.在整个文件中查找并高亮显示所有包含 "TODO" 的行：
            :g/TODO/highlight
        4.将所有以 "Chapter" 开头的行转换为大写：
            :g/^Chapter/s//\U&/ // 嵌套s命令（替换命令）

            
            

20.3 指定 ex 命令的执行范围
    不光 global可以指定范围，后面接的cmd也可以指定范围，下面将通过一个演示该如何使用.
    假设有一段 css 代码

        html{
            margin: 0;
            padding: 0;
            border: 0;
            font-size: 100%;
            font: inherit;
            vertical-align: baseline;
        }

        body{
            line-high: 1.5;
            color: black;
            background: white;
        }
    我们想对每组css内部属性按字母顺序进行排序。
    第一个办法：可以录制宏来自动化。首先通过模式来匹配 { ,即使用 /{。
    然后开始录制宏:"nvi{:sort" ,
    首先通过 n 来跳转到下一个匹配，
    然后使用 vi{ 通过文本对象来选中 {} 中的内容，
    最后针对选中来执行 sort 命令。


    但是我们可以使用 global 命令完成同样的操作。
    首先还是来构造对应的模式。我们可以通过 
    :g/{/ .+1,/}/-1 sort 这么一条命令来完成这一操作。
    我们来分析一下这条命令的意思。

    首先将这条命令按照 / 分为3个部分，
    第一部分是 { 表示匹配所有 { 之后的内容。
    第二部分是 .+1,/}/-1,它表示一个范围，
        范围分为两个部分，以 , 分割，前面一部分代表的是当前行的下一行，也就是{ 所在行的下一行，
        /} 表示匹配结束的 } 符号，后面跟一个 -1, 表示 } 所在的上一行，
        这个范围代表的就是 {} 之间的所有行。
    最后一个部分命令是 sort，在对应的这个范围中执行 sort 命令。
    

    针对上面解释的内容，我们可以对 global命令再做一个详细的使用格式：
        :[range]/g[lobal][!]/{start pattern}/ .{offsize},/{end pattern}/{offsize} [cmd]
        //可以按照如下方法理解。
        //第一个pattern确定了范围，后面的命令是在此 范围内操作，
        //cmd 是带范围的命令，其范围是用start_pattern,end_pattern表示的。
    这里我们也可以跟其他命令，例如将C函数中的代码进行缩进，那么就可以使用 :g/{/ .+1,/}/-1 >
    g命令还能套g命令，层层套，g!可以用v替代，少打点字。         

    将下面大括号内容按字母排序： 
            animal
            dog
            elephant
            fish

            html{
                border: 0;
                font-size: 100%;
                font: inherit;
                margin: 0;
                padding: 0;
                vertical-align: baseline;
            }

            body{
                background: white;
                color: black;
                line-high: 1.5;
            }


    简单方法：
        :/{/+1,/}/-1 sort

    复杂方法：
        :%s/{\s*\n\zs\(\_.\{-}\)\ze\n\s*}/\=join(sort(split(submatch(1), '\n')), "\n")/



文本处理：将下面文本按照已经给出的序号规律，继续添加序号。
    1 Graebert.ARES.Commander.2015.v2015.0.15.0.1.80.MacOSX-DVT.rar
    1 Graebert.ARES.Commander.2015.v2015.0.15.0.1.80.x64-DVT.rar
    1 Graebert.ARES.Commander.2015.v2015.0.15.0.1.80.x86-DVT.rar
    1 Graebert.ARES.Commander.2015.v2015.0.15.0.1.80.x64.Linux-DVT.rar
    2 yen.1415.851-Evermotion-Archmodels-Vol.055.part2.rar
    2 yen.1415.851-Evermotion-Archmodels-Vol.055.part1.rar
    2 yen.1415.851-Evermotion-Archmodels-Vol.055.part3.rar
    2 yen.1415.851-Evermotion-Archmodels-Vol.055.part4.rar
    PtOffice365APIsContacts.part4.rar
    PtOffice365APIsContacts.part2.rar
    PtOffice365APIsContacts.part1.rar
    PtOffice365APIsContacts.part3.rar
    iPhoneProductPhotography.part4.rar
    iPhoneProductPhotography.part2.rar
    iPhoneProductPhotography.part1.rar
    iPhoneProductPhotography.part5.rar
    iPhoneProductPhotography.part3.rar
    Le.Wan.Gu.Tr.part3.rar
    Le.Wan.Gu.Tr.part2.rar
    Le.Wan.Gu.Tr.part1.rar
    The.Seventh.Lie.2014.720p.BluRay.x264-WiKi.part1.rar
    The.Seventh.Lie.2014.720p.BluRay.x264-WiKi.part5.rar
    The.Seventh.Lie.2014.720p.BluRay.x264-WiKi.part4.rar
    The.Seventh.Lie.2014.720p.BluRay.x264-WiKi.part2.rar
    The.Seventh.Lie.2014.720p.BluRay.x264-WiKi.part3.rar
    The.Seventh.Lie.2014.720p.BluRay.x264-WiKi.part6.rar
    Stand.By.Me.Doraemon.2014.720p.BluRay.x264.DTS-WiKi.part2.rar
    Stand.By.Me.Doraemon.2014.720p.BluRay.x264.DTS-WiKi.part1.rar
    Stand.By.Me.Doraemon.2014.720p.BluRay.x264.DTS-WiKi.part3.rar
    Stand.By.Me.Doraemon.2014.720p.BluRay.x264.DTS-WiKi.part4.rar
    Stand.By.Me.Doraemon.2014.720p.BluRay.x264.DTS-WiKi.part7.rar
    Stand.By.Me.Doraemon.2014.720p.BluRay.x264.DTS-WiKi.part5.rar
    Stand.By.Me.Doraemon.2014.720p.BluRay.x264.DTS-WiKi.part6.rar
    Photoshop.CC.Portrait.Retouch.part2.rar
    Photoshop.CC.Portrait.Retouch.part1.rar
    Photoshop.CC.Portrait.Retouch.part5.rar
    Photoshop.CC.Portrait.Retouch.part4.rar
    Photoshop.CC.Portrait.Retouch.part3.rar
    How to Create Stopwatch App for Watchkit.part1.rar
    How to Create Stopwatch App for Watchkit.part4.rar
    How to Create Stopwatch App for Watchkit.part5.rar
    How to Create Stopwatch App for Watchkit.part2.rar
    How to Create Stopwatch App for Watchkit.part3.rar
    

way1:  分组+宏
    1.分组：
        :%s/\(^.*\)\..*\..*\n\1\@!/&\r/gc  
        或者
        :%s/\(^.*\).part\d\_.\{-}\n\1\@!/&\r/g
    2.定义一个寄存器为起始数
        :let @a=1
    3. 记录一个宏，然后这样操作，要确保文件末尾只有1个空行
        ^V}kI^Ra ^[}dd:let @a=@a+1^M   //跳到空行直接dd删除，后面不用删除了，但宏不能执行太多，否则将删除有用行。
        ^V}kI^Ra ^[}j:let @a=@a+1^M    //在文件末尾，j时失败，提前结束，不会执行寄存器赋值操作
        ^V}kI^Ra ^[:let @a=@a+1^M}j    // 最后虽然失败了，但也执行一次寄存器赋值操作，导致命令行显示操作过的命令
        
        ^V：  <C-v>        进入块操作模式
        }：跳到下一个空行
        }k： <s-]> k       选中一个组
        I:进入插入模式
        ^R:  <c-r>          引用寄存器的值
        a: 输入寄存器a的值
        ^[：<Esc> 退出插入模式
        ^M：<enter>   命令模式输入确定式输入确
        j:下移一行
        k:上移一行
        dd：删除一行
        let @a=@a+1：寄存器赋值  
    4.把你的宏运行 N 次，完成。N 的数量你在第第一步分组的时候应该已经知道。
        10@q
    5.删除掉空行
        :%s/^$\n//
way2:分组+g命令
    1.删除空行
        :g/^\s*$/d
    2.首行加空行
        ggO<esc>
    3.用正则表达式分组，每个分组后面加空行
        :%s/\v^(.*)\.part\d+\.rar$(\n\1\.part\d+\.rar$)@!/&\r/g
    4.设置@a初值
        :let @a=1
    5.用g命令(排除最后的空行)在空行与下一空行间的行执行s命令将@a 的值插入行首，之后将@a值加1
        :1,$-1 g/^$/+1 , /^$/-1 s/^/\=@a." "/g | let @a=@a+1
    6.删除所有空行
        :g/^\s*$/d
way3：脚本文件
    :source vimscr_file
从上面解决方法学习的知识点：
    1.\1\@!/&\r: 
        @!： 是零宽度相关知识 
        \r：是添加换行符 
        &:是匹配内容
        \1：是捕获1的内容
        \1\@!：是不以捕获1结尾的内容
    2.\=@a." "/g | let @a=@a+1
        @a:取出寄存器a的值
        ." ":  . 是连接两个值，如果没有. 数值后面 没有空格
        | 连接两个命令
    3. 1,$-1
        $:在普通命令指的是行末，在命令行指的是行数。
    4.vim 中使用零宽度断言，包括

        符号    vim 表符号	   描述	             示例	            vim 示例
        ?=	    \@=	        正先行断言 - 存在   foo(?=bar)	    foo\(bar\)\@=
        ?!	    \@!	        负先行断言 - 排除	foo(?!bar)	    foo\(bar\)\@!
        ?<=	    \@<=	    正后发断言 - 存在	(?<=foo)bar	    \(foo\) \@<=bar
        ?<!     \@<!	    负后发断言 - 排除	(?<!foo)bar	    \(foo\) \@<!bar

================================================================================================
                        21 跨文件搜索
================================================================================================
之前介绍了vim中的搜索模式，使用正则表达式可以很方便的在一个文件中进行搜索。
后续也介绍了如何使用 argsdo 命令在参数列表中进行替换操作。
但是到目前为止还没有介绍如何在工程目录中进行搜索，而这个功能是其他编辑器的基本功能。

vim 主要运行在 unix 平台，而 unix 平台信奉的哲学是专门的软件做好专门的事，
在多个文件中搜索关键字是 grep 这个程序的工作，vim本身并没有单独提供类似 grep 的功能，而是提供了方法直接调用 grep。
本篇我们将要讨论在vim中是如何调用 grep 进行搜索的。并且介绍其他搜索整个工程中代码的方式。

提前声明一下，因为vim中 grep 命令与 shell中的 grep 重名了，容易造成误解，
因此这里采用 :grep 来表示 vim 中的 grep 命令，grep 来表示 shell中的 grep，
也就是 vim中的命令都以 : 开头

21.1 grep 命令
    vim 中也提供了 :grep 命令，它是对 shell 中 grep 的封装。
    它可以让我们直接在vim中使用grep并且可以在vim中显示结果(当然我们也可以在命令模式中使用 :!grep 来调用shell的 grep 命令)。

    我们仍然以前面介绍的搜索 TODO 标签为例。
    我们先在 shell 中使用 grep 命令。

    grep -n "\-\- TODO" **/*.lua
    因为 --TODO 中的 - 在shell中是传参的标志，所以这里需要进行转义。
    -n 表示在输出的结果中显示行号。**/*.lua 表示在所有lua文件中进行搜索。我们可以看到，它输出了我们想要的结果。

    我们该如何根据这个结果快速跳转到对应位置呢？例如要跳转到 lua/basic/settings.lua 的第5行， 
    我们可以在 shell 中可以使用 nvim lua/basic/settings.lua +5 表示打开到该文件并跳转到第5行。

    当我们要频繁不同文件间进行跳转的时候，要频繁的退回到 shell 并执行 vim 来打开，操作上比较繁琐。
    vim 为这种需求提供了自己的工具—— :grep 命令和 :vimgrep

        在vim中输入 :grep "\-\- TODO" **/*.lua 会发现 vim 在下方显示了当前所有搜索到的内容。

    这里我们没有加上 -n 选项，但是它仍然显示了行号，vim默认自动为 grep 添加了 -n 选项。
    这些内容被存储在一个被称之为 quickfix 的列表中。可以通过这个列表快速跳转到对应的位置。

21.2 遍历 quickfix 列表
    quickfix 列表是由我们执行 :make 命令或者 :grep 命令所产生的，它会保存一个或者多个文件位置信息。
    我们可以使用以 c 开头的一组命令来遍历，下面列举出相关的命令：

        cnext：跳转到下一项
        cprev：跳转到上一项
        cfirst：跳转到第一项
        clast：跳转到最后一项
        cnfile：跳转到下一个文件的第一项
        cpfile：跳转到上一个文件的第一项
        cc n：跳转到第n项
        copen：打开 quickfix列表
        cclose: 关闭 quickfix列表
        后续使用 vim 时会大量使用到 quickfix 列表，为了减轻输入的负担，可以考虑将其定义为快捷键。
        :cnext 和 :cprev 命令前面可以加数字表示向后或者向前跳转多少次。例如我这里使用 :2cnext 表示向后跳转2次。




    我们可以使用 :copen 来使用新的窗口来显示 quickfix 列表中的内容。
    在这个窗口中可以使用 motion 命令来移动光标。quickfix 列表无法进行修改，因此这里只能移动光标。
    它比较特别的一点在于，如果我们在某一行按下回车键，那么vim会自动跳转到光标所在行对应的位置。
    quickfix 所在窗口总有一项处于高亮状态，这个状态表示当前我们在访问哪个位置的内容，
    我们可以通过窗口跳转来改变高亮的行，执行 :cnext 和 :cprev 以及 cc 之类的命令也可以修改当前高亮的行。
    例如我在这里执行 :cc 2 来跳转到第二条记录



    另外 vim 会自动保存之前产生的 quickfix 列表，并不会随着执行新的 :grep 而发生覆盖。
    我们可以使用 :colder 来查看上一个列表，使用 :cnewer 来查看下一个。

21.3 定制 grep命令
    vim 中的 :grep 是对 shell 中的 grep 的一个封装。前面说道，vim 中的 :grep 命令会默认加上 -n 这个选项，
    而 grep 还可以使用 -i 来忽略大小写，我想把这项也加入到 :grep 命令中该如何做呢？
    另外 :grep 是对 shell 中的 grep 的封装，现在我有更好的文本搜索工具，我想用它来替换 grep 该如何做呢？
    还有一个很奇怪的点，在使用 :grep 进行搜索的时候，我们明明输入的是 :grep "\-\- TODO **/*.lua",
    但是它给我们显示结果的时候显示的却是 
        :!grep -n "\-\- TODO" **/*.lua /dev/null 2>&1| tee /tmp/nvimPRHF8B/6 
    这是为什么呢？在这一小节我们将来探讨这些问题。

    当我们通过 vim 来执行 :grep 命令的时候，grepprg 负责制定将要调用的 shell 命令。
    grepformat 决定如何来 :grep 命令的输出结果。
    通过使用 :h grepprg 和 :h grepformat 看到，它们自身在 vim 中的默认值如下:

    grepprg = "grep -n $* /dev/null" 
    grepformat = "%f:%l:%m,%f:%l%m,%f  %l%m"
    在 grepprg 中 $* 表示占位符，它将被 :grep 命令中输入的内容替换，
    这也就解释了为什么最后在显示的时候，会在我们输入的基础之上加上了后面那些内容。 
    我们只需要对其做一些修改就可以使我们的 :grep 自动忽略大小写
        :set grepprg=grep\ -n\ -i\ $*
    我们看到，同样的命令现在多出来了一条小写的结果，另外从它的显示上看也已经加上了 -i 选项了。

    接下来我们来看看 vim是如何解析 :grep命令输出的。
    grepformat 中各种匹配格式是按照 ,来进行分割。
    也就是它定义了多组可能的输出格式，每组以 ,分割。
        %f表示文件名称、
        %l 表示行号，
        %m 表示匹配的行。

    了解这些之后，我们来试试使用别的命令来替换默认的 grep。
    这里我们以 ack 作为演示，当然你也可以使用其他的命令。
    插一句题外话，我觉得 ack 相较于 grep 来说，最大的优势在于它可以识别不同的文件类型，
    这样就可以做到只搜索某一类型文件中的内容，而且默认支持递归搜索当前目录下所有文件。

    在 shell 中，可以直接使用 ack "\-\- TODO" 来搜索所有的 todo 项，也可以使用 -i 来忽略大小写。
    在默认情况下 ack 会用两行来显示搜索到的结果，第一行是 文件名，第二行是行号和匹配行的内容。

    ack 默认会搜索当前目录中所有文件中的内容，所以这里可以不需要像 grep 那样给出具体的目录。
    我们可以使用 --nogroup 来达到与 grep相同的输出格式。

    我们可以使用 --nogroup 来使 ack 达到与 grep 相同的输出，因此这里也可以不修改 grepformat 的内容。
    我们只需要修改 grepprg 即可：

        set grepprg=ack\ --nogroup\ $*
    另外 ack 还支持添加 --column 来输出对应的列，配合 grepformat 我们可以做到精确定位到对应的行和列。这里我们设置
          
        set grepprg=ack\ --nogroup\ --column\ $*。
    同时设置 
        set grepformat=%f:%l:%c:%m

    从上图中可以看到，此时已经可以显示列号了，并且 grep 已经被替换成了 ack 了。

    vim 提供了很方便的方式让我们修改 :grep 命令的行为。
    但是我们在执行 :grep 的时候发现它在调用 ack 命令有时候会造成一定的疑惑或者误解。
    而且并不是每次我都想使用某一个 shell 程序的。
    例如这次我想用 grep 进行搜索，下一次我想用 ack 搜索，
    这样每次修改外部命令，我都得修改 grepprg 和 grepformat 想想也挺麻烦的。
    为什么不创建一个 :ack 命令专门用于使用外部的 ack，或者其他命令专门用于调用其他外部程序呢？
    目前很多插件都是这么干的。在后续介绍 vim配置的时候我们将会给出这样的例子。

21.4 vimgrep 简介
    除了使用 :grep 来调用外部的搜索命令外，vim 自身也提供了 :vimgrep 命令。
    它最大的特色是支持 vim 自己的正则表达式。它的使用格式如下:

        :vimgrep[!] /{pattern}/[j][g] {file}
    它的使用方式与之前介绍的搜索模式类似。只是它只支持2个标志，
    j 表示不进行跳转只是将匹配结果保存到 quickfix 列表中，
    默认情况下，它会跳转到第一个匹配的位置，并且将搜索结果保存到 quickfix 中。
    g 表示将所有匹配都记录下来，默认只记录每一行第一个匹配处。

    因为它与搜索模式下使用的模式相同，因此这里我们可以先用查找模式来在一个文件中进行试验，试验成功后再使用 vimgrep，
    否则错误的结果将会污染历史的 quickfix 列表，影响后续使用 colder 和 cnewer 。

    例如这里我还是搜索 --TODO， 可以现在单个文件中使用 :\v--\s+TODO进行搜索。

    然后使用模式域留空的方式查找，即 :vimgrep //gj **/*.lua


    关于 vimgrep的内容就介绍到这里了，一般我很少使用原装的 :grep和 :vimgrep。
    而是采用功能更加强大的其他搜索插件。各位小伙伴也不需要纠结究竟掌握它们中的哪个好，有更好的，直接用更好的就行。

================================================================================================
                        22 自动补全
================================================================================================

这篇文章我们将讨论 vim 自带的自动补全功能。
当然，针对自动补全功能有许多好用的插件，但是了解vim自带的功能有助于我们更好的用来插件的补全功能。
因为我见过有的配置文件将插件的功能配置的比原有的更难用，而且只用基本的功能不一定有原版的好用。
所以这里也介绍一下原始版本用法，算是帮助各位在以后的配置中提供一个标杆。

22.1 make 命令
    在了解自动补全之前，让我们先简单聊聊 :make 这个命令，
    它与上一篇文章中介绍的 :grep 命令类似，也是对 shell 命令的一个封装。
    它默认封装的是 make 命令。

    我们对 c/c++ 语言执行 :make 也就是在调用 shell 中的 make 命令。
    它会将编译产生的错误信息存储在 quickfix 列表中。我们上一节中介绍了如何操作 quickfix 列表。
    也介绍了如何对 :grep 命令进行改造。同样的 :make 也支持使用相同的方法进行改造。

    :make 命令中，使用 makeprg 来执行外部命令，使用 errorformat 来格式化输出到 quickfix 中。
    它们默认的值如下:

        makeprg="make"  
        errorformag="errorformat=%*[^"]"%f"%*\D%l: %m,"%f"%*\D%l: %m,%-G%f:%l: (Each undeclared identifier is reported only once,%-G%f:%l: for each function it appears in.),%-GIn file included from %f:%l:%c:,%-GIn file included from %f:%l:%c\,,%-GIn file incl uded from %f:%l:%c,%-GIn file included from %f:%l,%-G%*[ ]from %f:%l:%c,%-G%*[ ]from %f:%l:,%-G%*[ ]from %f:%l\,,%-G%*[ ]from %f:%l,%f:%l:%c:%m,%f(%l):%m,%f:%l:%m,"%f"\, line %l%*\D%c%*[^ ] %m,%D%*\a[%*\d]: Entering directory %*[`']%f',%X%* \a[%*\d]: Leaving directory %*[`']%f',%D%*\a: Entering directory %*[`']%f',%X%*\a: Leaving directory %*[`']%f',%DMaking %*\a in %f,%f|%l| %m"
    可以调整它们的值来适配不同的外部命令。这里就不再详细展开了，相信阅读过上一篇文章的小伙伴对这个应该不陌生。
    本来 :make 命令是vim中十分有用的一个命令，应该单独写一篇文章的。
    但是它于 :grep 重复度太高了，所以我决定在介绍其他内容的时候一笔带过。
    想了解详细信息的可以参考vim的用户手册。

22.2 自动补全
    自动补全可以在插入模式下触发，当我们触发补全功能的时候，vim会根据当前编辑会话中所有缓冲区的内容建立一张补全列表，
    然后根据当前光标左侧的字符进行检测，看在表中能否找到单词的一部分，能找到则会用这个未完成的单词对补全列表进行过滤，
    所以不是以它为开头的单词都被过滤掉，剩余的组成一个弹出式菜单供用户选择。效果如下：

    上述例子中，因为以 re 开头的原本只有 require 一项，为了展示补全效果这里我们新增一个以 re 开头的 return

    我们使用 <Ctrl +p> 和 <Ctrl + n> 来切换补全菜单中的上一条和下一条。
    除了这个，我们还有其他的用于操作补全菜单的快捷键。

        <Ctrl - n> : 使用来自补全列表中的下一项内容(next)
        <Ctrl - p> : 使用来自补全列表中的上一项内容(prev)
        <Down> : 与 <Ctrl -n> 相同
        <Up>: 与 <Ctrl - p> 相同
        <Ctrl -y> : 确认使用当前选中的匹配项
        <Ctrl - e> : 还原最初的输入项
        <Ctrl -h> : 从当前匹配项中删除一个字符
        <Ctrl - l> : 从当前匹配项中增加一个字符


    一般在输入字符的时候，如果有匹配项可以匹配vim会自动弹出，或者也可以手动使用 <Ctrl - n> 弹出匹配项菜单。
    在确定要使用的匹配后可以使用 <Ctrl-y> 来确认。

    有时候虽然弹出了匹配项菜单，但是匹配项太多了，而你需要的单词又在列表的太后面，
    这个时候可以使用 <Ctrl - e> 来退出菜单，手动输入几个字符使匹配项更加精确。
    或者也可以输入 <Ctrl -p> 到达最开始的项，即我们目前的输入，然后再次输入字符来精简菜单项，
    接着使用 <Ctrl - n> 弹出菜单。使用这种方式来一步一步的逼近我们想要的结果

22.3 自定义补全项来源
    默认情况下，vim 补全项主要来源于以下几个地方：

    22.3.1 缓冲区列表：
        vim补全项最基本的来源就是当前的缓冲区列表。
        它可以通过 <Ctrl - x><Ctrl - n> 来触发该项。
    22.3.2 包含文件，
        所有的编程语言都有包含文件的概念，例如 c/c++中的 #include , python 中的 import 。
        使用 <Ctrl-x><Ctrl-i> 可以触发这个选项，让vim从被包含文件中提取补全项。
        vim本身使用 c 语言编写的，它能够识别 c/c++ 语言中的关键字，
        我们可以指定 include 项来使 vim认识其他不同的关键字。
        一般常用的编程语言 vim 都能够识别，因此不需要修改 include 项。
    22.3.3 标签文件，
        我们使用 ctags 或者类似的插件的时候会生成一个标签文件，
        该文件会将扫描到代码中的关键字、函数、变量等的索引放入到一个文件中以供后续进行跳转。
        同时他们也会产生一系列的补全项到补全列表中。可以使用 <Ctrl+x><Ctrl+]> 来触发。


    一般直接使用 <Ctrl + n> 触发的是当前缓冲区列表中的补全项，使用 <Ctrl+x> 作为前缀，可以触发其他类型的补全项。
    这么做有一个好处是尽量精简补全列表，减少了我们手动遍历的过程。
    但是有时候我们并不知道我想要的内容该从哪里来，有没有什么办法能做到，
    用 <Ctrl + n> 这个按钮就可以调用其他所有来源的补全项呢？

    要做到这点，可以使用 complete 这个配置项。
    该项包含一组由逗号分隔的单个字符表示的参数，当参数出现时表示需要扫描该参数代表的位置。
    使用 set complete? 可以看到，缺省项为 complete=.,w,b,u,t 。
    我们可以使用 set complete-=i 或者 set complete+=k 来删除或者添加某个扫描位置。
    常见的位置参数如下所示：

        . : 表示当前以打开的缓冲区
        w : 当前打开的窗口
        b : 当前缓冲区列表
        u : 当前处于缓冲区列表中，但是未打开的缓冲区
        t : 当前标签文件
        U : 当前打开的，不属于缓冲区列表中的缓冲区
        k : 从字典文件中加载的补全项
        i : 从当前文件和包含文件中读取
        d : 从当前文件和包含文件中读取使用 define定义的宏

    完整的内容可以使用 :h 'complete' 来查看。

22.4 使用字典文件
    在上面的论述中，我们可以知道 vim 是可以自定义补全的字典文件，然后从字典中产生匹配的。
    我们可以使用 <Ctrl-x><Ctrl-k> 来加载字典中的匹配项。

    我们可以使用 set spell 来启动拼写检查，拼写检查也会产生新的字典文件。
    如果不想使用该项，也可以使用 set dictionary来指定含有一个或者多个单词的字典文件。

    在这个例子中我们在 nvim-config 目录中新建一个 spell.txt 文件，我们在里面写入如下内容

        require 
        return 
        request
    然后使用 set dictionary=./spell.txt ，接着删除 init.lua 中的 return ，
    输入 re 然后使用 <Ctrl+x><Ctrl+k> 这个时候我们发现它已经加载了

22.5 补全整行
    除了补全单词，vim还可以补全整行的内容，使用 <Ctrl+x><Ctrl+l> 可以触发补全整行的操作。
    补全行的补全项来源与补全单词相同，需要注意的是补全行的操作会自动忽略行首的缩进。
    补全行的操作与之前介绍的 yy 或者 :t 产生的效果相同，我们应该要根据实际情况分别使用。

22.6 补全文件名
    在 shell中输入命令可以使用 <Tab> 键来自动补全文件路径，vim中使用 <Ctrl+x><Ctrl+f> 来对文件路径和文件名进行补全。

    需要注意的是当我们使用相对路径来补全文件名时，使用的是工作目录，也就是你从哪个目录中进入的vim。
    我们可以在 vim中使用:cd来切换工作目录。
    例如我在 nvim-config这个工程的根目录执行 nvim init.lua，
    我们在这个文件中希望快速补全 basic/settings.lua这项，我们发现它在补全的时候报错，
    这个时候我们可以使用 :cd lua 来切换工作目录到 nvim-config/lua 。这个时候再执行补全命令就可以了。


22.7 根据具体编程语言生成补全
    上述补全在编辑普通文本的时候显的有点用处，但是作为程序员平时在写代码如果只能使用上述方式进行补全肯定会抓狂的。
    好在vim 提供了像其他IDE那样的基于编程语言的补全方式。
    使用该补全方式的快捷键为 <Ctrl+x><Ctrl+o> 要启用该方式，需要启动文件类型识别。

    nvim 中已经启用了这一特性，因此不必特意进行设置，但是这里我还是给出它的配置。

        vim.o.filetype="plugin"

    或者vim中可以使用如下代码

        set filetype=plugin set nocompatiable # 设置与vi 不兼容

    例如我们可以尝试着在 css 文件中使用补全
    vim 本身也确实支持很多语言的自动补全，但是为了获得完整的体验还是推荐使用各种专门的补全插件获得更好的体验

22.8 最后的总结
    在这边文章中，介绍了vim中补全项主要的几个来源分别是：当前缓冲区和缓冲区列表、包含文件、外部程序生成的标签等等。
    同时也介绍了如何使用快捷键来进行不同项的补全，现在对这些快捷键总结如下：

        <Ctrl + n>       : 普通关键字补全，主要来源自缓冲区列表和当前缓冲区
        <Ctrl+x><Ctrl+n> : 与 <Ctrl+n>作用相同
        <Ctrl+x><Ctrl+i> : 从包含文件中获取补全项
        <Ctrl+x><Ctrl+]> : 从外部标签中获取补全项
        <Ctrl+x><Ctrl+k> : 从字典文件中获取补全项
        <Ctrl+x><Ctrl+l> : 补全整行
        <Ctrl+x><Ctrl+f> : 补全文件名
        <Ctrl+x><Ctrl+o> : 根据编程语言来进行补全

        

 


